---
title: fend
key: 20180902
tags: fe
---

<!--more-->

# ?

## 计算机基础

### http

#### 1.HTTP 状态码

[HTTP 状态码](http://github.liwenfeng.net/2018/02/02/http-status-codes.html)

[如何理解 HTTP 状态码?](http://47.98.159.95/my_blog/http/004.html#_004-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-http-%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F)

#### 2.HTTP 和 HTTPS

[HTTP 和 HTTPS](http://github.liwenfeng.net/2018/02/03/http-and-htts.html)

[谈谈 HTTPS](https://juejin.im/post/59e4c02151882578d02f4aca)

[一个故事讲完 https](https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA)

#### 3.OSI 网络模型

[OSI 网络模型](https://www.jianshu.com/p/f32cfd6c208b)

#### 4.HTTP 304--Not Modified

响应体 Etag Last-Modified

请求体 If-None-Match If-Modified-Since

[HTTP 304--Not Modified](https://github.liwenfeng.net/2018/02/28/304NotModified.html)

#### 5.理解 TCP 序列号和确认号

[理解 TCP 序列号和确认号](https://github.liwenfeng.net/2019/01/13/seq-ack.html)

#### 6.关于域名的一些问题

两种负载均衡

一个域名对应不同的服务器 DNS 会自动负载均衡

利用 nginx upstream 负载均衡

[关于域名的一些问题](https://github.liwenfeng.net/2019/01/16/domain-q-a.html)

#### 7.简述 TCP 的三次握手过程

[简述 TCP 的三次握手过程](https://github.liwenfeng.net/2019/01/17/Three-way-Handshake.html)

#### 8.以前端角度讲从输入 url 到页面加载完成发生了什么?

[以前端角度讲从输入 url 到页面加载完成发生了什么?](https://github.liwenfeng.net/2019/03/12/url-fe.html)

[细说浏览器输入 URL 后发生了什么](https://juejin.im/post/5e32449d6fb9a02fe4581907)

#### 9.upgrade-insecure-requests

[upgrade-insecure-requests](https://github.liwenfeng.net/2019/11/11/upgrade-insecure-requests.html)

#### 10.HTTP 报文结构是怎样的?

[HTTP 报文结构是怎样的?](http://47.98.159.95/my_blog/http/001.html#_001-http-%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F)

#### 11.预测最近面试会考 Cookie 的 SameSite 属性

SameSite 可以有下面三种值：

Strict 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。

Lax 允许部分第三方请求携带 Cookie

None 无论是否跨站都会发送 Cookie

之前默认是 None 的，Chrome80 后默认是 Lax。

[预测最近面试会考 Cookie 的 SameSite 属性](https://juejin.im/post/5e718ecc6fb9a07cda098c2d)

#### 12.【面试篇】寒冬求职之你必须要懂的 Web 安全

XSS(Cross-Site Scripting，跨站脚本攻击)

反射型 XSS

DOM 型 XSS

存储型 XSS

-->做好数据过滤

CSRF(Cross-site request forgery,跨站请求伪造)

-->添加验证码

-->判断请求的来源：检测 Referer(并不安全，Referer 可以被更改)

-->使用 Token(主流)

-->Samesite Cookie 属性

检测工具

[Mozilla HTTP Observatory](https://github.com/mozilla/http-observatory/)

[【面试篇】寒冬求职之你必须要懂的 Web 安全](https://juejin.im/post/5cd6ad7a51882568d3670a8e)

#### 13.深入理解浏览器的缓存机制

- 缓存位置

  Service Worker

  Memory Cache

  Disk Cache

  Push Cache

- 浏览器缓存

  强缓存 expires cache-contorl

  协商缓存 last-modified(if-modified-since) etag(if-none-match)

  两种缓存强制缓存优先于协商缓存,各自中后者又优先于前者

- 用户行为的影响

  地址栏输入地址

  普通刷新

  强制刷新

- 实际应用场景

  对不常变化的资源使用缓存,减少服务器资源开销

[深入理解浏览器的缓存机制](https://www.jianshu.com/p/54cc04190252)

### 算法

#### 1.基础排序

[排序算法](https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg)

[JS 实现十大经典排序](https://github.liwenfeng.net/2017/04/20/js-sort.html)

#### 2.给定一个字符串(数字或大小写字母), 找出最长的对称的子串(如有多个,输出任意一个);

例如
输入"abbaad"
输出"abba"

```javascript
function reverseStr(str) {
  return str.split('').reverse().join('')
}

function findStr(str) {
  var maxStrings = ''
  if (str.length == 1 || str == reverseStr(str)) {
    return str
  }
  for (var i = 0; i < str.length; i++) {
    for (j = str.length; j > i; j--) {
      var subStrings = str.substring(i, j)
      if (subStrings == reverseStr(subStrings)) {
        if (subStrings.length > maxStrings.length) {
          maxStrings = subStrings
        }
      }
    }
  }
  return maxStrings
}
console.log(findStr(readline()))
```

使用 js 实现的,其中 readline()可以读取输入的字符串,然后每次不断获取子字符串,如果字符串和它的反转字符串一样,并且比当前所得到的最大对称字符串一样,则进行保存

#### 3.给定两个数字(0-9)字符串(长度不限)求它们的乘积;

```javascript
var multiply = function (num1, num2) {
  if (num1 == '0' || num2 == '0') {
    return '0'
  }
  var res = new Array(num1.length + num2.length)
  for (var i = 0; i < res.length; i++) {
    res[i] = 0
  }

  var a = num1.split('').reverse()
  var b = num2.split('').reverse()

  for (var i = 0; i < a.length; i++) {
    for (var j = 0; j < b.length; j++) {
      res[i + j] += a[i] * b[j]
    }
  }

  var carry = 0
  var str = []

  for (var i = 0; i < res.length; i++) {
    res[i] += carry
    carry = parseInt(res[i] / 10)
    res[i] = res[i] % 10
    str[i] = res[i]
  }

  str = str.reverse().join('')

  var index = 0
  while (str[index] === '0') {
    index++
  }

  return str.substring(index)
}
console.log(multiply(readline(), readline()))
```

#### 4.javascript 实现千位分隔符

[javascript 实现千位分隔符](https://github.liwenfeng.net/2017/03/30/JS-achieve-1000-bit-separators.html)

#### 5.斐波那契数列

[斐波那契数列](https://github.liwenfeng.net/2019/01/03/fibonacci.html)

#### 6.数组去重

[数组去重](https://github.liwenfeng.net/2019/01/04/array-uniq.html)

#### 7.函数传参

[函数传参](https://github.liwenfeng.net/2019/01/05/Function-pass.html)

#### 8.函数的上下文

[函数的上下文](https://github.liwenfeng.net/2019/01/06/The-context-of-the-function.html)

#### 9.返回函数

[返回函数](https://github.liwenfeng.net/2019/01/07/Return-function.html)

#### 10.使用闭包

[使用闭包](https://github.liwenfeng.net/2019/01/08/Using-closures.html)

#### 11.二次封装函数

[二次封装函数](https://github.liwenfeng.net/2019/01/09/SecondaryEncapsulationFunction.html)

#### 12.使用 apply 调用函数

[使用 apply 调用函数](https://github.liwenfeng.net/2019/01/10/callTheFunctionWithApply.html)

#### 13.柯里化

[柯里化](https://github.liwenfeng.net/2019/01/11/Currie.html)

#### 14.模块与对象

[模块与对象](https://github.liwenfeng.net/2019/01/12/modulesAndObjects.html)

#### 15.二进制转换

[二进制转换](https://github.liwenfeng.net/2019/01/13/binaryConversion.html)

#### 16.属性遍历

[属性遍历](https://github.liwenfeng.net/2019/01/13/propertyTraversal.html)

#### 17.正则相关

[正则相关](https://github.liwenfeng.net/2019/01/13/regexp.html)

[正则的扩展](https://es6.ruanyifeng.com/?search=%23&x=0&y=0#docs/regex)

### 其他

#### 1.打电话使用的数据传输方式是(电路交换),手机上网使用的数据传输方式是(分组交换)

电路交换通信的双方在通信过程中会一直占用信道
分组交换将报文进行分组,采用存储转发技术

#### 2.[TCP 连接的建立和释放(三次握手和四次挥手)](https://blog.csdn.net/d_leo/article/details/73865427)

#### 3.TCP 协议的拥塞控制就是防止过多的数据注入到网络中,这样可以使网络中的路由器或链路不致过载;常用的方法有:

慢开始、拥塞控制

#### 4.对于京东商城高流量访问,预防 Ddos 的方法可以有?

限制同时打开 SYN 半链接的数目;

#### 5.端口

21 FTP
80 HTTP
443 HTTPS
8080 闲置

#### 6.原始数据为 011011111111111111110010 采用比特填充技术填充后的发送数据为

011011111011111011111010010
在帧的传输起始标志和结束标志之间,每当出现 5 个 1 之后,发送器就会插入一个附加的 0.

> 参考《TCP/IP 详解卷 1 协议》第 2 章链路层 -> 2.6 PPP 点对点协议
> [真题](https://www.nowcoder.com/questionTerminal/5a5cace1b12e41e6974744fe1f70ebe5)

#### 7.公司门户网站随着访问用户增加需要扩展服务器数量,每台服务器在 DNS 配置时,域名与主机相同,为达到负载均衡,DNS 服务器需要开启(启用循环)

#### 8.IP 数据报的收发方进行跨网投递时,发送方需利用 ARP 协议获取哪些信息(发送方本网段路由器对应端口的 MAC 地址)

#### 9.数据链路层一般都提供 3 种基本服务,即无确认的无连接服务、有确认的无连接服务、有确认 的面向连接的服务;

(1)无确认的无连接服务 无确认的无连接服务是源机器向目的机器发送独立的帧,而目的机器对收到的帧不作确认; 如果由于线路上的噪声而造成帧丢失,数据链路层不作努力去恢复它,恢复工作留给上层去完成; 这类服务适用于误码率很低的情况,也适用于像语音之类的实时传输,实时传输情况下有时数据延误比数据损坏影响更严重; 大多数局域网在数据链路层都使用无确认的无连接服务;

(2)有确认的无连接服务 这种服务仍然不建立连接,但是所发送的每一帧都进行单独确认; 以这种方式,发送方就会知道帧是否正确地到达;如果在某个确定的时间间隔内,帧没有到达,就必须重新发此帧;

(3)有确认的面向连接的服务 采用这种服务,源机器和目的机器在传递任何数据之前,先建立一条连接; 在这条连接上所发送的每一帧都被编上号,数据链路层保证所发送的每一帧都确实已收到; 而且,它保证每帧只收到一次,所有的帧都是按正确顺序收到的;面向连接的服务为网络进程间提供了可靠地传送比特流的服务;

#### 10. 进程的基本属性

进程是动态的
多个进程可以含有相同的程序
和多个进程可以并发运行

#### 11.对于只在表的首、尾两端进行插入操作的线性表,宜采用的数据结构为 用尾指针表示的单循环链表

#### 12.选择排队作业中等待时间最长的作业优先调度,该调度算法是 先来先服务调度算法

#### 13.二叉树

- 采用哪种遍历方法可唯一确定一棵二叉树?
  给定一棵二叉树的后序和中序遍历序列
  给定一棵二叉树的先序和中序遍历序列

#### 14.最大堆小习题

[](https://github.liwenfeng.net/2016/06/06/max-heap-question.html)

## 前端基础

### js

> 数据类型、运算、对象、Function、继承、闭包、作用域、事件、Prototype、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步请求、模板引擎、模块 Flux、同构、算法、ECMAScript6、Nodejs、HTTP

#### 1.数据类型

- javascript 中有 5 中数据类型(也称为基本数据类型)Undefined、Null、Boolean、Number 和 String,还有一种复杂数据类型——object, object 本质是由一组键值对组成的,object、function 和 array 等对象都是引用型数据;

- 最新的 ECMAScript 标准定义了 8 种数据类型:

- 7 种原始类型:

  Boolean

  Null

  Undefined

  Number

  BigInt

  String

  Symbol

  和 Object

[javascript 数据类型和数据结构](https://developer.mozilla.org/zh-CN/docs/Web/javascript/Data_structures)

#### 2.浅拷贝 Object.assign()和 let b={...a}效果一样

[关于深浅拷贝,参考掘金文章](https://juejin.im/post/5c20509bf265da611b585bec)

#### 3.当一个 Ajax 请求由于跨域问题导致请求不能顺利完成时,你觉得是哪个环节导致的?

- 浏览器;

- 浏览器 不会 将存在跨域限制的 服务端响应 正常 交给客户端代码去处理;

#### 4.如果你只是用 typeof 来检查该变量,不论是 array 还是 object,都将返回‘object’

```javascript
console.log(Object.prototype.toString.call('jerry')) //[object String]

console.log(Object.prototype.toString.call(12)) //[object Number]

console.log(Object.prototype.toString.call(true)) //[object Boolean]

console.log(Object.prototype.toString.call(undefined)) //[object Undefined]

console.log(Object.prototype.toString.call(null)) //[object Null]

console.log(Object.prototype.toString.call({ name: 'jerry' })) //[object Object]

console.log(Object.prototype.toString.call(function () {})) //[object Function]

console.log(Object.prototype.toString.call([])) //[object Array]

console.log(Object.prototype.toString.call(new Date())) //[object Date]

console.log(Object.prototype.toString.call(/\d/)) //[object RegExp] function Person(){};

console.log(Object.prototype.toString.call(new Person())) //[object Object]
```

#### 5.javascript 中实现跨域的方式总结

- 第一种方式 jsonp 请求;jsonp 的原理是利用`<script>`标签的跨域特性,可以不受限制地从其他域中加载资源,类似的标签还有`<img>`.

- 第二种方式 document.domain;这种方式用在主域名相同子域名不同的跨域访问中

- 第三种方式 window.name;window 的 name 属性有个特征在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个 window.name 的,每个页面对 window.name 都有读写的权限,window.name 是持久存在一个窗口载入过的所有页面中的,并不会因新页面的载入而进行重置;

- 第四种方式 window.postMessage;window.postMessages 是 html5 中实现跨域访问的一种新方式,可以使用它来向其它的 window 对象发送消息,无论这个 window 对象是属于同源或不同源;

- 第五种方式 CORS;CORS 背后的基本思想,就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通,从而决定请求或响应是应该成功还是应该失败;

- 第六种方式 Web Sockets;Web Sockets 原理在 JS 创建了 web socket 之后,会有一个 HTTP 请求发送到浏览器以发起连接;取得服务器响应后,建立的连接会使用 HTTP 升级从 HTTP 协议交换为 web sockt 协议;

[前端常见跨域解决方案](https://github.liwenfeng.net/2019/03/15/Cross-domain.html)

#### 6.javascript 的 typeof 运算符

```javascript
typeof Symbol() //"symbol"

typeof Number() //"number"

typeof String() //"string"

typeof Function() //"function"

typeof Object() //"object"

typeof Boolean() //"boolean"

typeof null //"object"

typeof undefined //"undefined"
```

#### 7.创建对象的几种方式

> 完成函数 createModule,调用之后满足如下要求

> 1、返回一个对象

> 2、对象的 greeting 属性值等于 str1, name 属性值等于 str2

> 3、对象存在一个 sayIt 方法,该方法返回的字符串为 greeting 属性值 + ', ' + name 属性值

```javascript
// <!-- ###原型模式 -->
function createModule(str1, str2) {
  function Obj() {
    this.greeting = str1
    this.name = str2
  }
  Obj.prototype.sayIt = function () {
    return this.greeting + ', ' + this.name
  }
  return new Obj()
}
```

```javascript
// <!-- ###构造函数模式 -->
function createModule(str1, str2) {
  function Obj() {
    this.greeting = str1
    this.name = str2
    this.sayIt = function () {
      return this.greeting + ', ' + this.name
    }
  }
  return new Obj()
}
```

```javascript
//  <!-- ###创建对象模式 -->
function createModule(str1, str2) {
  function CreateObj() {
    obj = new Object()
    obj.greeting = str1
    obj.name = str2
    obj.sayIt = function () {
      return this.greeting + ', ' + this.name
    }
    return obj
  }
  return CreateObj()
}
```

```javascript
// <!-- ###字面量模式 -->
function createModule(str1, str2) {
  var obj = {
    greeting: str1,
    name: str2,
    sayIt: function () {
      return this.greeting + ', ' + this.name
    },
  }
  return obj
}
```

#### 8.修改 this 指向

> 封装函数 f,使 f 的 this 指向指定的对象

```javascript
function bindThis(f, oTarget) {
  return f.bind(oTarget)
}
```

#### 9. 面向对象编程 与 面向过程编程的区别?

- 面向过程编程注重于编程的步骤,而面向对象编程注重于对象之间的交互。

- 面向过程的编程应该关注的是如何使用函数去实现既定的功能。

- 面向对象的编程,是关注如何把相关的功能,包括函数和数据有组织地捆绑到一个对象身上,它强调"封装""继承""多态",把一些数据和相关的操作封装起来包装成对象,是所有的模块达到更好的内聚性和更低的耦合性,使不同的对象之间减少依赖性,从而达到代码的可复用性,提高编程效率。

#### 10. this 指向问题

```javascript
// this一般有几种调用场景
var obj = {
  a: 1,
  b: function () {
    console.log(this)
  },
}
// 1、作为对象调用时,指向该对象 obj.b(); // 指向obj
// 2、作为函数调用, var b = obj.b; b(); // 指向全局window
// 3、作为构造函数调用 var b = new Fun(); // this指向当前实例对象
// 4、作为call与apply调用 obj.b.apply(object, []); // this指向当前的object
```

[javascript 深入之从 ECMAScript 规范解读 this](https://github.com/mqyqingfeng/Blog/issues/7)

[this 指向](https://github.liwenfeng.net/2019/01/01/this-direction.html)

[javascript 中的 this](https://juejin.im/post/59748cbb6fb9a06bb21ae36d)

#### 11. 普通函数 与 箭头函数的区别

[ES6 系列之箭头函数](https://github.com/mqyqingfeng/Blog/issues/85)

#### 12. eval 函数是做什么的?

[eval()](https://developer.mozilla.org/zh-CN/docs/Web/javascript/Reference/Global_Objects/eval)

#### 13. 函数节流 与 函数防抖

- 节流

节流的原理很简单

如果你持续触发事件,每隔一段时间,只执行一次事件。

根据首次是否执行以及结束后是否执行,效果有所不同,实现的方式也有所不同。
我们用 leading 代表首次是否执行,trailing 代表结束后是否再执行一次。

关于节流的实现,有两种主流的实现方式,一种是使用时间戳,一种是设置定

- 防抖

防抖的原理就是

你尽管触发事件,但是我一定在事件触发 n 秒后才执行,如果你在一个事件触发的 n 秒内又触发了这个事件,那我就以新的事件的时间为准,n 秒后才执行,总之,就是要等你触发完事件 n 秒内不再触发事件,我才执行,真是任性呐!

[javascript 专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26)
[javascript 专题之跟着 underscore 学防抖](https://github.com/mqyqingfeng/Blog/issues/22)

#### 14. 作用域链是什么?

```javascript
/* 
在《javascript深入之变量对象》中讲到,当查找变量的时候,会先从当前上下文的变量对象中查找,如果没有找到,就会从父级(词法层面上的父级)执行上下文的变量对象中查找,一直找到全局上下文的变量对象,也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

在《javascript深入之词法作用域和动态作用域》中讲到,函数的作用域在函数定义的时候就决定了。

对于每个执行上下文,都有三个重要属性:
变量对象(Variable object,VO)
作用域链(Scope chain)
this

在函数上下文中,我们用活动对象(activation object, AO)来表示变量对象
 */
```

[javascript 深入之作用域链](https://github.com/mqyqingfeng/Blog/issues/6)

#### 15. 原型链继承的机制是什么?

[javascript 深入之从原型到原型链](https://github.com/mqyqingfeng/Blog/issues/2)

#### 16. 垃圾回收(GC)的机制

[前端面试谈谈 JS 垃圾回收机制](https://segmentfault.com/a/1190000018605776?utm_source=tag-newest)

#### 17. promise

[ES6 系列之我们来聊聊 Promise](https://github.com/mqyqingfeng/Blog/issues/98)

#### 18.深拷贝 浅拷贝

[js 深拷贝 vs 浅拷贝](https://juejin.im/post/59ac1c4ef265da248e75892b)

[javascript 专题之深浅拷贝](https://github.com/mqyqingfeng/Blog/issues/32)

#### 19.数组常用方法\字符串常用方法\对象常用方法

```javascript
// 字符串 相关的属性和方法

concat() // 将两个或多个字符的文本组合起来，返回一个新的字符串。

indexOf() // 返回字符串中一个子串第一处出现的索引。如果没有匹配项，返回 -1 。

charAt() // 返回指定位置的字符。

lastIndexOf() // 返回字符串中一个子串最后一处出现的索引，如果没有匹配项，返回 -1 。

match() // 检查一个字符串是否匹配一个正则表达式。

substr() 函数 // 返回从 string 的 startPos 位置，长度为 length 的字符串

substring() // 返回字符串的一个子串。传入参数是起始位置和结束位置。

slice() // 提取字符串的一部分，并返回一个新字符串。

replace() // 用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。

search() // 执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。

split() // 通过将字符串划分成子串，将一个字符串做成一个字符串数组。

length // 返回字符串的长度，所谓字符串的长度是指其包含的字符的个数。

toLowerCase() // 将整个字符串转成小写字母。

toUpperCase() // 将整个字符串转成大写字母。
```

```js
// Array 相关的属性和方法

Array //对象属性 constructor 返回对创建此对象的数组函数的引用。

length //设置或返回数组中元素的数目。

prototype //使您有能力向对象添加属性和方法。

Array 对象方法 concat() // 连接两个或更多的数组，并返回结果。

join() // 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。

pop() // 删除并返回数组的最后一个元素。

shift() // 删除并返回数组的第一个元素

push() // 向数组的末尾添加一个或更多元素，并返回新的长度。

unshift() // 向数组的开头添加一个或更多元素，并返回新的长度。

reverse() // 颠倒数组中元素的顺序。

slice() // 从某个已有的数组返回选定的元素

sort() // 对数组的元素进行排序

splice() // 删除元素，并向数组添加新元素。

toSource() // 返回该对象的源代码。

toString() // 把数组转换为字符串，并返回结果。

toLocaleString() // 把数组转换为本地数组，并返回结果。

valueOf() // 返回数组对象的原始值//
```

[String](https://developer.mozilla.org/zh-CN/docs/Web/javascript/Reference/Global_Objects/String)

[Array](https://developer.mozilla.org/zh-CN/docs/Web/javascript/Reference/Global_Objects/Array)

[Object](https://developer.mozilla.org/zh-CN/docs/Web/javascript/Reference/Global_Objects/Object)

[js 中对象常用方法](https://blog.csdn.net/qq_42278182/article/details/93618323)

[字符串的扩展](https://es6.ruanyifeng.com/?search=%23&x=0&y=0#docs/string)

[字符串的新增方法](https://es6.ruanyifeng.com/?search=%23&x=0&y=0#docs/string-methods)

[数组的扩展](https://es6.ruanyifeng.com/?search=%23&x=0&y=0#docs/array)

[对象的扩展](https://es6.ruanyifeng.com/?search=%23&x=0&y=0#docs/object)

[对象的新增方法](https://es6.ruanyifeng.com/?search=%23&x=0&y=0#docs/object-methods)

#### 20.你真的理解 事件冒泡 和 事件捕获 吗?

[你真的理解 事件冒泡 和 事件捕获 吗?](https://juejin.im/post/5cc941436fb9a03236394027)

#### 21.js 赋值顺序/var a = {n: 1} var b = a; a.x = a = {n: 2} console.log(a.x); console.log(b.x)

```js
var a = { n: 1 }
var b = a
a.x = a = { n: 2 }

console.log(a.x) // undefined
console.log(b.x) // { n: 2 }

// . 的运算优先级大于赋值运算的优先级。
```

```js
var a = { n: 1 }
var b = a
b.n = a.f = { n: 2 }

// 重点看第三步 给a添加f属性  然后给b添加n属性 都是 {n:2}

console.log(a) // {n: {…}, f: {…}}n:2
// f: {n: 2}
// n: {n: 2}
console.log(b) // 同 a
```

[js 赋值顺序/var a = {n: 1} var b = a; a.x = a = {n: 2} console.log(a.x); console.log(b.x)](https://www.cnblogs.com/hongxiaogang/articles/11712120.html)

[js 赋值顺序/var a = {n: 1} var b = a; a.x = a = {n: 2} console.log(a.x); console.log(b.x)](https://blog.csdn.net/mx18519142864/article/details/83111207)

[运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

#### 22.标记语句 label

> 标记语句可以和 break 或 continue 语句一起使用。标记就是在一条语句前面加个可以引用的标识符(identifier)。

[label](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label)

#### 23.ES6 Set WeakSet

> Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。

```js
new Set([iterable])
```

> WeakSet 对象是一些对象值的集合, 并且其中的每个对象值都只能出现一次。在 WeakSet 的集合中是唯一的

```js
new WeakSet([iterable])
```

- WeakSet 和 Set 对象的区别有两点:

  - 与 Set 相比，WeakSet 只能是对象的集合，而不能是任何类型的任意值。

  - WeakSet 持弱引用：集合中对象的引用为弱引用。 如果没有其他的对 WeakSet 中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着 WeakSet 中没有存储当前对象的列表。 正因为这样，WeakSet 是不可枚举的。

[Set 和 Map 数据结构](https://es6.ruanyifeng.com/#docs/set-map)

[Set](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)

[WeakSet](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet)

[ES6 系列之模拟实现一个 Set 数据结构](https://github.com/mqyqingfeng/Blog/issues/91)

#### 24.ES6 Set WeakSet

> Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。

```js
new Map([iterable])
```

> WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。

```js
new WeakMap([iterable])
```

[Set 和 Map 数据结构](https://es6.ruanyifeng.com/#docs/set-map)

[Map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)

[WeakMap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)

[ES6 系列之 WeakMap](https://github.com/mqyqingfeng/Blog/issues/92)

#### 25.ES6 Symbol

> symbol 是一种基本数据类型 (primitive data type)。Symbol()函数会返回 symbol 类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象;它的静态方法会暴露全局的 symbol 注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法："new Symbol()"。

> 每个从 Symbol()返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符;这是该数据类型仅有的目的。

```js
const symbol1 = Symbol()
const symbol2 = Symbol(42)
const symbol3 = Symbol('foo')

console.log(typeof symbol1)
// expected output: "symbol"

console.log(symbol2 === 42)
// expected output: false

console.log(symbol3.toString())
// expected output: "Symbol(foo)"

console.log(Symbol('foo') === Symbol('foo'))
// expected output: false
```

[Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)

[Symbol](https://es6.ruanyifeng.com/#docs/symbol)

[ES6 系列之模拟实现 Symbol 类型](https://github.com/mqyqingfeng/Blog/issues/87)

#### 26.ES6 Iterator 和 for...of 循环

> JavaScript 原有的表示"集合"的数据结构，主要是数组(**Array**)和对象(**Object**)，ES6 又添加了 **Map** 和 **Set**。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是 **Map**，**Map** 的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。

> 遍历器(Iterator)就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作(即依次处理该数据结构的所有成员)。

> Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口;二是使得数据结构的成员能够按某种次序排列;三是 ES6 创造了一种新的遍历命令 `for...of` 循环，Iterator 接口主要供 `for...of` 消费。

> `for...of 语句`在可迭代对象(包括 `Array`，`Map`，`Set`，`String`，`TypedArray`，`arguments` 对象等等)上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句

```js
for (variable of iterable) {
  //statements
}

/* 
除了数组之外,还有一些数据结构默认部署了 Symbol.iterator 属性.

所以 for...of 循环可以使用的范围包括:

数组
Set
Map
类数组对象,如 arguments 对象、DOM NodeList 对象
Generator 对象
字符串
 */
```

[Iterator 和 for...of 循环](https://es6.ruanyifeng.com/#docs/iterator#for---of-%E5%BE%AA%E7%8E%AF)

[ES6 系列之迭代器与 for of](https://github.com/mqyqingfeng/Blog/issues/90)

[for...of](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of)

[Iterator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Iterator)

#### 27.ES6 Promise

> Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.

```js
new Promise( function(resolve, reject) {...} /* executor */  );
参数
```

[Promise 对象](https://es6.ruanyifeng.com/#docs/promise)

[ES6 系列之我们来聊聊 Promise](https://github.com/mqyqingfeng/Blog/issues/98)

[ES6 系列之异步处理实战](https://github.com/mqyqingfeng/Blog/issues/101)

[Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)

[使用 Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)

#### 28.ES6 Generator

> Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。

[Generator 函数的语法](https://es6.ruanyifeng.com/#docs/generator)

[Generator 函数的异步应用](https://es6.ruanyifeng.com/#docs/generator-async)

[ES6 系列之 Generator 的自动执行](https://github.com/mqyqingfeng/Blog/issues/99)

[Generator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator)

#### 29.ES6 async function

> async function 用来定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 **Promise** 返回其结果。如果你在代码中使用了异步函数，就会发现它的语法和结构会更像是标准的同步函数。

[async 函数](https://es6.ruanyifeng.com/#docs/async)

[async function](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function)

[ES6 系列之我们来聊聊 Async](https://github.com/mqyqingfeng/Blog/issues/100)

#### 30.ES6 Proxy

> Proxy 对象用于定义基本操作的自定义行为(如属性查找、赋值、枚举、函数调用等)。

[Proxy](https://es6.ruanyifeng.com/#docs/proxy)

[ES6 系列之 defineProperty 与 proxy](https://github.com/mqyqingfeng/Blog/issues/107)

[Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)

#### 31.ES6 Reflect

> Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers 的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。

[Reflect](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect)

[Reflect](https://es6.ruanyifeng.com/#docs/reflect)

#### 32.ES6 Class

> ECMAScript 2015 中引入的 JavaScript 类实质上是 JavaScript 现有的基于原型的继承的**语法糖**。类语法不会为 JavaScript 引入新的面向对象的继承模型。

[Class 的基本语法](https://es6.ruanyifeng.com/#docs/class)

[Class 的继承](https://es6.ruanyifeng.com/#docs/class-extends)

[ES6 系列之 Babel 是如何编译 Class 的(上)](https://github.com/mqyqingfeng/Blog/issues/105)

[ES6 系列之 Babel 是如何编译 Class 的(下)](https://github.com/mqyqingfeng/Blog/issues/106)

[类](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes)

#### 33.ES6 Decorator

> 装饰器(Decorator)是一种与类(class)相关的语法，用来注释或修改类和类方法。

[装饰器](https://es6.ruanyifeng.com/#docs/decorator)

[ES6 系列之我们来聊聊装饰器](https://github.com/mqyqingfeng/Blog/issues/109)

#### 34.ES6 系列之私有变量的实现

[ES6 系列之私有变量的实现](https://github.com/mqyqingfeng/Blog/issues/110)

[类元素](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Class_elements)

#### 35.js Function

> 每个 JavaScript 函数实际上都是一个 Function 对象。运行 (function(){}).constructor === Function // true 便可以得到这个结论。

[Function](https://developer.mozilla.org/zh-CN/docs/Web/javascript/Reference/Global_Objects/Function)

[函数的扩展](https://es6.ruanyifeng.com/?search=%23&x=0&y=0#docs/function)

### html & css

对 Web 标准的理解(结构、表现、行为)、浏览器内核、渲染原理、依赖管理、兼容性、CSS 语法、层次关系,常用属性、布局、选择器、权重、盒模型、Hack、CSS 预处理器、CSS3、Flexbox、CSS Modules、Document flow、BFC、HTML5(离线 & 存储、Histoy,多媒体、WebGL\SVG\Canvas)

#### 1.Doctype 作用?标准模式与兼容模式各有什么区别?

(1)<!DOCTYPE>声明位于 HTML 文档中的第一行,处于 `<html>` 标签之前,告知浏览器的解析器用什么文档标准解析这个文档,DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现.

(2)标准模式的排版 和 JS 运作模式都是以该浏览器支持的最高标准运行,在兼容模式中,页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作.

#### 2.HTML5 为什么只需要写 <!DOCTYPE HTML> ?

HTML5 不基于 SGML,因此不需要对 DTD 进行引用,但是需要 doctype 来规范浏览器的行为(让浏览器按照它们应该的方式来运行);

而 HTML4.01 基于 SGML,所以需要对 DTD 进行引用,才能告知浏览器文档所使用的文档类型.

[文档类型定义(DTD，Document Type Definition)是一种特殊文档，它规定、约束符合标准通用标示语言(SGML)或 SGML 子集可扩展标示语言(XML)规则的定义和陈述。](https://baike.baidu.com/item/%E6%96%87%E6%A1%A3%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89/12724347?fromtitle=dtd&fromid=2661276&fr=aladdin)

[SGML 一般指标准通用置标语言;标准通用标记语言(以下简称"通用标言")，是一种定义电子文档结构和描述其内容的国际标准语言;通用标言为语法置标提供了异常强大的工具，同时具有极好的扩展性，因此在数据分类和索引中非常有用;是所有电子文档标记语言的起源，早在万维网发明之前"通用标言"就已存在。](https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80/10471466?fromtitle=SGML&fromid=2901416&fr=aladdin)

#### 3.行内元素有哪些?块级元素有哪些? 空(void)元素有那些?

首先:CSS 规范规定,每个元素都有 display 属性,确定该元素的类型,每个元素都有默认的 display 值,如 div 的 display 默认值为"block",则为"块级"元素;span 默认 display 属性值为"inline",是"行内"元素.记住一些常用的

(1)行内元素(inline)有:

- b(吸引读者), big(字体大一号,已废弃), i(斜体), small(文本的字体变小一号), tt(类似 code,已废弃)

- abbr(展示缩写), acronym(类似 abbr,已废弃), cite(表示一个作品的引用), code(呈现一段计算机代码), dfn(标记了被定义的术语), em(着重元素), kbd(用于表示用户输入), strong(表示文本十分重要), samp(用于标识计算机程序输出), var(表示数学表达式或编程上下文中的变量名称)

- a(锚元素), bdo(改写了文本的方向性), br(生成一个换行(回车)符号), img(将一份图像嵌入文档。), map(与 area 属性一起使用来定义一个图像映射(一个可点击的链接区域).), object(引入一个外部资源), q(封闭的并且是短的行内引用的文本), script(用于嵌入或引用可执行脚本), span(通用行内容器，并没有任何特殊语义), sub(定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更低并且更小。), sup(定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更高并且更小。)

- button(表示一个可点击的按钮), input(为基于 Web 的表单创建交互式控件), label(表示用户界面中某个元素的说明。), select(表示一个提供选项菜单的控件), textarea(元素表示一个多行纯文本编辑控件)

(2)块级元素(block)有:

```html
<!-- <address>联系方式信息。<article> HTML5文章内容。<aside> HTML5伴随内容。<audio> HTML5音频播放。<blockquote>块引用。

<canvas> HTML5绘制图形。<dd>定义列表中定义条目描述。<div>文档分区。<dl>定义列表。<fieldset>表单元素分组。

<figcaption> HTML5图文信息组标题<figure> HTML5图文信息组 (参照 <figcaption>)。<footer> HTML5区段尾或页尾。<form>表单。

<h1>, <h2>, <h3>, <h4>, <h5>, <h6>标题级别 1-6.<header> HTML5区段头或页头。<hgroup> HTML5标题组。

<hr>水平分割线。<noscript>不支持脚本或禁用脚本时显示的内容。<ol>有序列表。<output> HTML5表单输出。<p>行。

<pre>预格式化文本。<section> HTML5一个页面区段。<table>表格。<tfoot>表脚注。<ul>无序列表。<video> HTML5视频。 -->
```

(3)行类块元素(inline-block)(能够识别宽高): input, select

(4)常见的空元素(</>): br hr img input link meta

```css
/* 根据默认W3C HTML4规范的示例： */
html,
address,
blockquote,
body,
dd,
div,
dl,
dt,
fieldset,
form,
frame,
frameset,
h1,
h2,
h3,
h4,
h5,
h6,
noframes,
ol,
p,
ul,
center,
dir,
hr,
menu,
pre {
  display: block;
  unicode-bidi: embed;
}
li {
  display: list-item;
}
head {
  display: none;
}
table {
  display: table;
}
tr {
  display: table-row;
}
thead {
  display: table-header-group;
}
tbody {
  display: table-row-group;
}
tfoot {
  display: table-footer-group;
}
col {
  display: table-column;
}
colgroup {
  display: table-column-group;
}
td,
th {
  display: table-cell;
}
caption {
  display: table-caption;
}
th {
  font-weight: bolder;
  text-align: center;
}
caption {
  text-align: center;
}
body {
  margin: 8px;
}
h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
h2 {
  font-size: 1.5em;
  margin: 0.75em 0;
}
h3 {
  font-size: 1.17em;
  margin: 0.83em 0;
}
h4,
p,
blockquote,
ul,
fieldset,
form,
ol,
dl,
dir,
menu {
  margin: 1.12em 0;
}
h5 {
  font-size: 0.83em;
  margin: 1.5em 0;
}
h6 {
  font-size: 0.75em;
  margin: 1.67em 0;
}
h1,
h2,
h3,
h4,
h5,
h6,
b,
strong {
  font-weight: bolder;
}
blockquote {
  margin-left: 40px;
  margin-right: 40px;
}
i,
cite,
em,
var,
address {
  font-style: italic;
}
pre,
tt,
code,
kbd,
samp {
  font-family: monospace;
}
pre {
  white-space: pre;
}
button,
textarea,
input,
select {
  display: inline-block;
}
big {
  font-size: 1.17em;
}
small,
sub,
sup {
  font-size: 0.83em;
}
sub {
  vertical-align: sub;
}
sup {
  vertical-align: super;
}
table {
  border-spacing: 2px;
}
thead,
tbody,
tfoot {
  vertical-align: middle;
}
td,
th,
tr {
  vertical-align: inherit;
}
s,
strike,
del {
  text-decoration: line-through;
}
hr {
  border: 1px inset;
}
ol,
ul,
dir,
menu,
dd {
  margin-left: 40px;
}
ol {
  list-style-type: decimal;
}
ol ul,
ul ol,
ul ul,
ol ol {
  margin-top: 0;
  margin-bottom: 0;
}
u,
ins {
  text-decoration: underline;
}
br:before {
  content: '\A';
  white-space: pre-line;
}
center {
  text-align: center;
}
:link,
:visited {
  text-decoration: underline;
}
:focus {
  outline: thin dotted invert;
}

/* Begin bidirectionality settings (do not change) */
BDO[DIR='ltr'] {
  direction: ltr;
  unicode-bidi: bidi-override;
}
BDO[DIR='rtl'] {
  direction: rtl;
  unicode-bidi: bidi-override;
}

*[DIR='ltr'] {
  direction: ltr;
  unicode-bidi: embed;
}
*[DIR='rtl'] {
  direction: rtl;
  unicode-bidi: embed;
}

@media print {
  h1 {
    page-break-before: always;
  }
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    page-break-after: avoid;
  }
  ul,
  ol,
  dl {
    page-break-before: avoid;
  }
}
```

[行内元素](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements)

[块级元素](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements)

[不同浏览器(版本)、HTML4(5)、CSS2 等实际略有差异](http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements)

[element](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/${element})

#### 4.页面导入样式时,使用 link 和@import 有什么区别?

(1)link 属于 XHTML 标签,除了加载 CSS 外,还能用于定义 RSS, 定义 rel 连接属性等作用;而@import 是 CSS 提供的,只能用于加载 CSS;

(2)页面被加载的时,link 会同时被加载,而@import 引用的 CSS 会等到页面被加载完再加载;

(3)import 是 CSS2.1 提出的,只在 IE5 以上才能被识别,而 link 是 XHTML 标签,无兼容问题;

(4)link 支持使用 js 控制 DOM 去改变样式,而@import 不支持;

[@import](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import)

#### 5.介绍一下你对浏览器内核的理解?

首先,浏览器内核主要分成两部分:渲染引擎(layout engineer 或 Rendering Engine)和 JS 引擎.范德萨

渲染引擎:负责取得网页的内容(HTML、XML、图像等等)、整理讯息(例如加入 CSS 等),以及计算网页的显示方式,然后会输出至显示器或打印机.浏览器的内核的不同对于网页的语法解释会有不同,所以渲染的效果也不相同.所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核.

JS 引擎则:解析和执行 javascript 来实现网页的动态效果.

最开始渲染引擎和 JS 引擎并没有区分的很明确,后来 JS 引擎越来越独立,内核就倾向于只指渲染引擎.

```js
//检测呈现引擎和浏览器
var ua = navigator.userAgent

//检测平台
var p = navigator.platform
```

#### 6.常见的浏览器内核有哪些?

Trident 内核:IE,MaxThon,TT,The World,360,搜狗浏览器等.[又称 MSHTML]

Gecko 内核:Netscape6 及以上版本,FF,MozillaSuite/SeaMonkey 等

Presto 内核:Opera7 及以上. [Opera 内核原为:Presto,现为:Blink;]

Webkit 内核:Safari,Chrome 等. [ Chrome 的:Blink(WebKit 的分支)]

详细文章:

[浏览器内核的解析和对比](http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html)

#### 7.html5 有哪些新特性、移除了那些元素?如何处理 HTML5 新标签的浏览器兼容问题?如何区分 HTML 和 HTML5?

- HTML5 现在已经不是 SGML 的子集,主要是关于图像,位置,存储,多任务等功能的增加.

  - 绘画 canvas;
  - 用于媒介回放的 video 和 audio 元素;
  - 本地离线存储 localStorage 长期存储数据,浏览器关闭后数据不丢失;
  - sessionStorage 的数据在浏览器关闭后自动删除;
  - 语意化更好的内容元素,比如 article、footer、header、nav、section;
  - 表单控件,calendar、date、time、email、url、search;
  - 新的技术 webworker, websocket, Geolocation;

- 移除的元素:

  - 纯表现的元素:basefont,big,center,font,s,strike,tt,u;
  - 对可用性产生负面影响的元素:frame,frameset,noframes;

- 支持 HTML5 新标签:

  IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签,

  可以利用这一特性让这些浏览器支持 HTML5 新标签,

  浏览器支持新标签后,还需要添加标签默认的样式.

  当然也可以直接使用成熟的框架、比如 html5shim;

  ```html
  <!--[if lt IE 9]>
    <script>
      src = 'http://html5shim.googlecode.com/svn/trunk/html5.js'
    </script>
  <![endif]-->
  ```

- 如何区分 HTML5:

  - DOCTYPE 声明

  - 新增的结构元素

  - 功能元素

[Canvas](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API)

[MDN 中的 HTML5](http://www.mamicode.com/info-detail-2937246.html)

#### 8.简述一下你对 HTML 语义化的理解?

- 用正确的标签做正确的事情.

- html 语义化让页面的内容结构化,结构更清晰,便于对浏览器、搜索引擎解析;

- 即使在没有样式 CSS 情况下也以一种文档格式显示,并且是容易阅读的;

- 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重,利于 SEO;

- 使阅读源代码的人对网站更容易将网站分块,便于阅读维护理解.

#### 9.HTML5 的离线储存怎么使用,工作原理?能不能解释一下浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢?

> 已废弃 该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。

> 在此刻使用这里描述的应用程序缓存功能高度不鼓励; 它正在处于从 Web 平台中被删除的过程。请改用 Service Workers 代替。事实上，在 Firefox 44 中，当 AppCache 用于为页面提供离线支持时，控制台中现在显示一条警告消息，建议开发人员改用 Service workers 代替 (bug 1204581)。

- 概念:

  首先了解一下什么是离线存储技术,该技术是指在用户没有与因特网连接时,可以正常访问站点或应用,在用户与因特网连接时,更新用户机器上的缓存文件.

- 原理:

  HTML5 的离线存储是基于一个新建的.appcache 文件的缓存机制(不是存储技术),通过这个文件上的解析清单离线存储资源,这些资源就会像 cookie 一样被存储了下来.之后当网络在处于离线状态下时,浏览器会通过被离线存储的数据进行页面展示.

- 如何使用:

  1. 页面头部像下面一样加入一个 manifest 的属性;

  2. 在 cache.manifest 文件的编写离线存储的资源;

  ```bash
     CACHE MANIFEST
     #v0.11
     CACHE:
     js/app.js
     css/style.css
     NETWORK:
     resourse/logo.png
     FALLBACK:
     / /offline.html
  ```

  3. 在离线状态时,操作 window.applicationCache 进行需求实现.

- 浏览器对离线储存资源如何进行管理和加载:

  1. 在线的情况下,浏览器发现 html 头部有 manifest 属性,它会请求 manifest 文件,如果是第一次访问 app,那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储.如果已经访问过 app 并且资源已经离线存储了,那么浏览器就会使用离线的资源加载页面,然后浏览器会对比新的 manifest 文件与旧的 manifest 文件,如果文件没有发生改变,就不做任何操作,如果文件改变了,那么就会重新下载文件中的资源并进行离线存储.

  2. 离线的情况下,浏览器就直接使用离线存储的资源.

- 详细请参考:

  [HTML5 离线缓存-manifest 简介](http://yanhaijing.com/html/2014/12/28/html5-manifest/)

  [有趣的 HTML5:离线存储](http://segmentfault.com/a/1190000000732617)

  [使用应用缓存(已废弃的特性)](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache)

  [使用 Service Workers](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers)

  [Service Worker API](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API)

#### 10.请描述一下 cookies,sessionStorage 和 localStorage 的区别?

> Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销(尤其是在移动环境下)。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API (本地存储和会话存储)或 IndexedDB 。

- cookie 是网站为了标示用户身份而储存在用户本地终端(Client Side)上的数据(通常经过加密).

- cookie 数据始终在同源的 http 请求中携带(即使不需要),只会在浏览器和服务器间来回传递.

- sessionStorage 和 localStorage 不会自动把数据发给服务器,仅在本地保存.

- 存储大小:

  cookie 数据大小不能超过 4k.

  sessionStorage 和 localStorage 虽然也有存储大小的限制,但比 cookie 大得多,可以达到 5M 或更大.

- 有期时间:

  localStorage 存储持久数据,浏览器关闭后数据不丢失除非主动删除数据;

  sessionStorage 数据在当前浏览器窗口关闭后自动删除.

  cookie 设置的 cookie 过期时间之前一直有效,即使窗口或浏览器关闭

[HTTP cookies](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)

[使用 Web Storage API](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API)

[Window.sessionStorage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage)

[Window.localStorage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage)

#### 11.iframe 有那些缺点?

- iframe 的优点：

  1.iframe 能够原封不动的把嵌入的网页展现出来。

  2.如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。

  3.网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。

  4.如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由 iframe 来解决。

- iframe 的缺点：

  1.会产生很多页面，**不容易管理**。

  2.iframe 框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，**用户体验度差**。

  3.代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理 iframe 中的内容，所以使用 iframe 会**不利于搜索引擎优化**。

  4.很多的移动设备(PDA 手机)无法完全显示框架，**设备兼容性差**。

  5.iframe 框架页面会**增加服务器的 http 请求**，对于大型网站是不可取的。

- 分析了这么多，**现在基本上都是用 Ajax 来代替 iframe，所以 iframe 已经渐渐的退出了前端开发**。

#### 12.Label 的作用是什么?是怎么用的?

> HTML `<label>` 元素(标签)表示用户界面中某个元素的说明。

label 标签常用来定义表单控制间的关系,当用户选择该标签时,浏览器会自动将焦点转到和标签相关的表单控件上.

```html
<!-- 第一种写法 -->
<label for="Name">Number:</label>
<input type="text" name="Name" id="Name" />

<!-- 第二种写法 -->
<label> Date:<input type="text" name="B" /> </label>
```

[<label>](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/label)

#### 13.HTML5 的 form 如何关闭自动完成功能?

给不想要提示的 form 或某个 input 设置为 autocomplete=off.

#### 14.如何实现浏览器内多个标签页之间的通信? (阿里)

- 方法: WebSocket、SharedWorker、localstorage

- Web Socket 特点:

  (0)它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于**服务器推送技术**的一种。

  (1)建立在 TCP 协议之上,服务器端的实现比较容易.

  (2)与 HTTP 协议有着良好的兼容性.默认端口也是 80 和 443,并且握手阶段采用 HTTP 协议,因此握手时不容易屏蔽,能通过各种 HTTP 代理服务器.

  (3)数据格式比较轻量,性能开销小,通信高效.

  (4)可以发送文本,也可以发送二进制数据.

  (5)没有同源限制,客户端可以与任意服务器通信.

  (6)协议标识符是 ws(如果加密,则为 wss),服务器网址就是 URL.

- Web Worker 特点:

  (1)我们都知道 javascript 是单线程的,但是浏览器是拥有过个线程的比如:gui 渲染线程、JS 引擎线程、事件触发线程、异步 http 请求线程.

  (2)webworker 作为浏览器的一个新特性,可以提供一个额外的线程来执行一些 js 代码,并且不会影响到浏览器用户界面.

  (3)应用场景:比如页面中包含耗时较大的算法代码时,就会阻塞线程影响浏览器渲染等等.这时候就可把耗时代码,放到 webworker(另一个线程)中执行.

  (4)注意,这种多线程能力不是 javascript 语言原生具有的,而是浏览器宿主环境提供的.

  (5)普通的 webworker 直接使用 new Worker()即可创建,这种 webworker 是当前页面专有的.然后还有种共享 worker(SharedWorker),这种是可以多个标签页、iframe 共同使用的,接下来介绍如何使用 **SharedWorker** 实现标签页之间的通信.

  ```js
  let worker = new SharedWorker('worker.js')
  worker.port.addEventListener(
    'message',
    (e) => {
      console.log('来自worker的数据：', e)
    },
    false
  )
  worker.port.start()
  ```

- localStorage 特点:

  (1)localStorage 是浏览器多个标签共用的存储空间,所以可以用来实现多标签之间的通信(sessionStorage 是会话级的存储空间,每个标签页都是单独的).

  (2)直接在 window 对象上添加监听即可

  (3)localstorge 另一个浏览上下文里被添加、修改或删除时,它都会触发一个事件,我们通过监听事件,控制它的值来进行页面信息通信(注意 quirks:Safari 在无痕模式下设置 localstorge 值时会抛出 QuotaExceededError 的异常)

  (4)onstorage 以及 storage 事件,针对都是非当前页面对 localStorage 进行修改时才会触发,当前页面修改 localStorage 不会触发监听函数.然后就是在对原有的数据的值进行修改时才会触发,比如原本已经有一个 key 为 a 值为 b 的 localStorage,你再执行:localStorage.setItem('a', 'b')代码,同样是不会触发监听函数的.

  ```js
  window.onstorage = function (e) {
    console.log(e)
  }

  // 或者
  window.addEventListener('storage', (e) => {
    console.log(e)
  })

  // e 是一个对象,可以得到如下属性
  /* 
  e.key
  e.oldValue
  e.newValue
  e.url
  JSON.stringify(e.storageArea) 
  */
  ```

- 参考:

1. [实现多个标签页之间通信的几种方法(sharedworker)](https://www.jianshu.com/p/31facd4934d7)

2. [WebSocket 教程](http://www.ruanyifeng.com/blog/2017/05/websocket.html)

3. [SharedWorker](https://developer.mozilla.org/zh-CN/docs/Web/API/SharedWorker)

4. [使用 Web Storage API](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API)

5. [WindowEventHandlers](https://developer.mozilla.org/zh-CN/docs/Web/API/WindowEventHandlers)

6. [WindowEventHandlers.onstorage](https://developer.mozilla.org/zh-CN/docs/Web/API/WindowEventHandlers/onstorage)

7. [EventTarget.addEventListener()](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener)

8. [事件参考](https://developer.mozilla.org/zh-CN/docs/Web/Events)

9. [Web Worker 使用教程](http://www.ruanyifeng.com/blog/2018/07/web-worker.html)

10. [Web Workers API](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API)

#### 15.webSocket 如何兼容低浏览器?(阿里)

- Adobe Flash Socket

- ActiveX HTMLFile (IE)

- 基于 multipart 编码发送 XHR

- 基于长轮询的 XHR

[轮询、长轮询与 Web Socket 的前端实现](https://www.cnblogs.com/zhaowinter/p/5332681.html)

[轮询、长轮询、长连接、websocket](https://my.oschina.net/wangzifan2019/blog/3187896/print)

[Server-sent events](https://developer.mozilla.org/zh-CN/docs/Server-sent_events)

#### 16.页面可见性(Page Visibility API) 可以有哪些用途?

通过 visibilityState 的值检测页面当前是否可见,以及打开网页的时间等;在页面被切换到其他后台进程的时候,自动暂停音乐或视频的播放;

```javascript
document.addEventListener('visibilitychange', function () {
  console.log(document.visibilityState)

  // Document.visibilityState 可用的值如下：

  // 'visible' : 此时页面内容至少是部分可见. 即此页面在前景标签页中，并且窗口没有最小化.
  // 'hidden' : 此时页面对用户不可见. 即文档处于背景标签页或者窗口处于最小化状态，或者操作系统正处于 '锁屏状态' .
  // 'prerender' : 页面此时正在渲染中, 因此是不可见的 (considered hidden for purposes of document.hidden). 文档只能从此状态开始，永远不能从其他值变为此状态.注意: 浏览器支持是可选的.
  // 'unloaded' : 页面从内存中卸载清除. 注意: 浏览器支持是可选的.

  // doSomething...

  // 典型用法是防止当页面正在渲染时加载资源, 或者当页面在背景中或窗口最小化时禁止某些活动.
})
```

[Document.visibilityState](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/visibilityState)

#### 17.如何在页面上实现一个圆形的可点击区域?

```html
<!-- 1. map+area 或者 svg; <area shape="circle" />  -->

<!-- 2. border-radius  -->

<!-- 3. 纯 js 实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等-->
```

[answer](https://blog.csdn.net/lxcao/article/details/52809221)

#### 18.实现不使用 border 画出 1px 高的线,在不同浏览器的标准模式与怪异模式下都能保持一致的效果.

```html
<div style="height:1px;overflow:hidden;background:red"></div>
```

#### 19.网页验证码是干嘛的,是为了解决什么安全问题.

- 区分用户是计算机还是人的公共全自动程序

- 可以防止恶意破解密码、刷票、论坛灌水

- 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试

#### 20.title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别?

- title 属性没有明确意义只表示是个标题,H1 则表示层次明确的标题,对页面信息的抓取也有很大的影响;

- strong 是标明重点内容,有语气加强的含义,使用阅读设备阅读网络时: strong 会重读,而 B 是展示强调内容;

- i 内容展示为斜体,em 表示强调的文本;

- Physical Style Elements -- 自然样式标签

  b, i, u, s, pre

- Semantic Style Elements -- 语义样式标签

  strong, em, ins, del, code

- 应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签.

#### 21.介绍一下标准的 CSS 的盒子模型?低版本 IE 的盒子模型有什么不同的?

(1)有两种, IE 盒子模型、W3C 盒子模型;

(2)盒模型: 内容(content)、填充(padding)、边框(border)、边界(margin);

(3)区 别: IE 的 content 部分把 border 和 padding 计算了进去;

#### 22.CSS 选择符有哪些?哪些属性可以继承?

1. id 选择器( # myid)

2. 类选择器(.myclassname)

3. 标签选择器(div, h1, p)

4. 相邻选择器(h1 + p)

5. 子选择器(ul > li)

6. 后代选择器(li a)

7. 通配符选择器( \* )

8. 属性选择器(a[rel = "external"])

9. 伪类选择器(a:hover, li:nth-child)

- 可继承的样式: font-size font-family color, UL LI DL DD DT;

- 不可继承的样式:border padding margin width height;

#### 23.CSS 优先级算法如何计算?

- 优先级就近原则,同权重情况下样式定义最近者为准;

- 载入样式以最后载入的定位为准;

- 优先级为:

  - 同权重: 内联样式表(标签内部)> 嵌入样式表(当前文件中)> 外部样式表(外部文件中);

  - !important > id > class > tag;

  - important 比 内联优先级高;

- 优先级由高到低可分为

  - 在属性后面使用!important 会覆盖页面内任何位置定义的元素样式;

  - 作为 style 属性写在元素内的样式

  - id 选择器

  - 类选择器 = 伪类选择器=属性选择器 (后面的样式会覆盖前面的样式)

  - 标签选择器

  - 通配符选择器

  - 浏览器自定义的样式

[优先级](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity)

#### 24.CSS3 新增伪类有那些?

- p:first-of-type 选择属于其父元素的首个 p 元素的每个 p 元素;

- p:last-of-type 选择属于其父元素的最后 p 元素的每个 p 元素;

- p:only-of-type 选择属于其父元素唯一的 p 元素的每个 p 元素;

- p:only-child 选择属于其父元素的唯一子元素的每个 p 元素;

- p:nth-child(2) 选择属于其父元素的第二个子元素的每个 p 元素;

- ::after 在元素之前添加内容,也可以用来做清除浮动;

- ::before 在元素之后添加内容;

- :enabled 控制表单控件的选用状态;

- :disabled 控制表单控件的禁用状态;

- :checked 单选框或复选框被选中;

#### 25.如何居中 div?

```css
/* 1. 水平居中:给 div 设置一个宽度,然后添加 margin:0 auto 属性 */

div {
  width: 200px;
  margin: 0 auto;
}

/* 2. 让绝对定位的 div 居中 */

div {
  position: absolute;
  width: 300px;
  height: 300px;
  margin: auto;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  background-color: pink; /* 方便看效果 */
}

/* 3. 水平垂直居中一

  确定容器的宽高 宽 500 高 300 的层
  设置层的外边距 */

div {
  position: relative; /* 相对定位或绝对定位均可 */
  width: 500px;
  height: 300px;
  top: 50%;
  left: 50%;
  margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */
  background-color: pink; /* 方便看效果 */
}

/* 4. 水平垂直居中二

  未知容器的宽高,利用 `transform` 属性 */

div {
  position: absolute; /* 相对定位或绝对定位均可 */
  width: 500px;
  height: 300px;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: pink; /* 方便看效果 */
}

/* 5. 水平垂直居中三

  利用 flex 布局
  实际使用时应考虑兼容性 */

.container {
  display: flex;
  align-items: center; /* 垂直居中 */
  justify-content: center; /* 水平居中 */
}

.container div {
  width: 100px;
  height: 100px;
  background-color: pink; /* 方便看效果 */
}
```

#### 26.display 有哪些值?说明他们的作用.

1. block

   块类型.默认宽度为父元素宽度,可设置宽高,换行显示;

2. none

   元素不显示,并从文档流中移除;

3. inline

   行内元素类型;默认宽度为内容宽度,不可设置宽高,同行显示;

4. inline-block

   默认宽度为内容宽度,可以设置宽高,同行显示;

5. list-item

   象块类型元素一样显示,并添加样式列表标记;

6. table

   此元素会作为块级表格来显示;

7. inherit

   规定应该从父元素继承 display 属性的值;

#### 27.position 的值 relative 和 absolute 定位原点是?

1. absolute

   生成绝对定位的元素,相对于值不为 static 的第一个父元素进行定位.

2. fixed (老 IE 不支持)

   生成绝对定位的元素,相对于浏览器窗口进行定位.

3. relative

   生成相对定位的元素,相对于其正常位置进行定位.

4. static

   默认值.没有定位,元素出现在正常的流中(忽略 top, bottom, left, right z-index 声明).

5. inherit

   规定从父元素继承 position 属性的值.

#### 28.CSS3 有哪些新特性?

- 新增各种 CSS 选择器 (:not(.input):所有 class 不是"input"的节点)

- 圆角 (border-radius:8px)

- 多列布局 (multi-column layout)

- 阴影和反射 (Shadow\Reflect)

- 文字特效 (text-shadow、)

- 文字渲染 (Text-decoration)

- 线性渐变 (gradient)

- 旋转 (transform)

- 缩放,定位,倾斜,动画,多背景;例如:transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation...

#### 29.请解释一下 CSS3 的 Flexbox(弹性盒布局模型),以及适用场景?

[Flex 布局教程语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

#### 30.grid 布局

[CSS Grid 网格布局教程](http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html)

#### 31.用纯 CSS 创建一个三角形的原理是什么?

```css
/* 把上、左、右三条边隐藏掉(颜色设为 transparent) */

#demo {
  width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent transparent red transparent;
}
```

#### 32.一个满屏 品 字布局 如何设计?

1. 简单的方式:

   上面的 div 宽 100%,

   下面的两个 div 分别宽 50%,

   然后用 float 或者 inline 使其不换行即可

2. 其他方式: flex grid

#### 33.css 多列等高如何实现?

1. padding margin 实现

   利用 padding-bottom|margin-bottom 正负值相抵;

   设置父容器设置超出隐藏(overflow:hidden),这样子父容器的高度就还是它里面的列没有设定 padding-bottom 时的高度,

   当它里面的任 一列高度增加了,则父容器的高度被撑到里面最高那列的高度,

   其他比这列矮的列会用它们的 padding-bottom 补偿这部分高度差.

2. table 实现

   父容器 display 设为 table

   子容器 display 设为 table-cell

3. flex 实现

   父容器 display 设为 flex

   子项目 flex 设为 1

4. grid 实现

   父容器 display 设为 grid;grid-auto-flow 设置为 colum 先列后行

[实现多列等高布局的几种方法](https://www.cnblogs.com/art-poet/p/12557108.html)

#### 34.经常遇到的浏览器的兼容性有哪些?原因,解决方法是什么,常用 hack 的技巧 ?

- png24 位的图片在 iE6 浏览器上出现背景,解决方案是做成 PNG8.

* 浏览器默认的 margin 和 padding 不同.解决方案是加一个全局的\*{margin:0;padding:0;}来统一.

* IE6 双边距 bug:块属性标签 float 后,又有横行的 margin 情况下,在 ie6 显示 margin 比设置的大.

  浮动 ie 产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}

  这种情况之下 IE 会产生 20px 的距离,解决方案是在 float 的标签样式控制中加入\_display:inline;将其转化为行内属性.(\_这个符号只有 ie6 会识别)

  渐进识别的方式,从总体中逐渐排除局部.

  首先,巧妙的使用"\9"这一标记,将 IE 游览器从所有情况中分离出来.

  接着,再次使用"+"将 IE8 和 IE7、IE6 分离开来,这样 IE8 已经独立识别.

  ```css
  .bb {
    background-color: red; /*所有识别*/
    background-color: #00deff\9; /*IE6、7、8识别*/
    +background-color: #a200ff; /*IE6、7识别*/
    _background-color: #1e0bd1; /*IE6识别*/
  }
  ```

- IE 下,可以使用获取常规属性的方法来获取自定义属性,

  也可以使用 getAttribute()获取自定义属性;

  Firefox 下,只能使用 getAttribute()获取自定义属性.

  解决方法:统一通过 getAttribute()获取自定义属性.

- IE 下,even 对象有 x,y 属性,但是没有 pageX,pageY 属性;

  Firefox 下,event 对象有 pageX,pageY 属性,但是没有 x,y 属性.

  解决方法:(条件注释)缺点是在 IE 浏览器下可能会增加额外的 HTTP 请求数.

- Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,

  可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.

- 超链接访问过后 hover 样式就不出现了 被点击访问过的超链接样式不在具有 hover 和 active 了解决方法是改变 CSS 属性的排列顺序:

  L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}

#### 35.li 与 li 之间有看不见的空白间隔是什么原因引起的?有什么解决办法?

行框的排列会受到中间空白(回车\空格)等的影响,因为空格也属于字符,这些空白也会被应用样式,占据空间,所以会有间隔,把字符大小设为 0,就没有空格了.

#### 36.为什么要初始化 CSS 样式.

- 因为浏览器的兼容问题,不同浏览器对有些标签的默认值是不同的,如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异.

- 当然,初始化样式会对 SEO 有一定的影响,但鱼和熊掌不可兼得,但力求影响最小的情况下初始化.

- 最简单的初始化方法: \* {padding: 0; margin: 0;} (强烈不建议)

#### 37.absolute 的 containing block(容器块)计算方式跟正常流有什么不同?

无论属于哪种,都要先找到其祖先元素中最近的 position 值不为 static 的元素,然后再判断:

1. 若此元素为 inline 元素,则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形;

2. 否则,则由这个祖先元素的 padding box 构成.

   如果都找不到,则为 initial containing block.

3. 补充:

   1. static(默认的)/relative:简单说就是它的父元素的内容框(即去掉 padding 的部分)

   2. absolute: 向上找最近的定位为 absolute/relative 的元素

   3. fixed: 它的 containing block 一律为根元素(html/body),根元素也是 initial containing block

#### 38.position 跟 display、margin collapse、overflow、float 这些特性相互叠加后会怎么样?

- 如果元素的 display 为 none,那么元素不被渲染,position,float 不起作用

- 如果元素拥有 position:absolute;或者 position:fixed;属性那么元素将为绝对定位,float 不起作用

- 如果元素 float 属性不是 none,元素会脱离文档流,根据 float 属性值来显示

- 有浮动,绝对定位,inline-block 属性的元素,margin 不会和垂直方向上的其他元素 margin 折叠

#### 39.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的?在不同浏览器下以后什么区别?

- 对于普通元素 visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与 display:none;表现相同;

- 如果目标元素为 table,visibility:collapse;将 table 隐藏,但是会占据页面布局空间;

- 仅在 Firefox 下起作用,IE 会显示元素,Chrome 会将元素隐藏,但是占据空间;

#### 40.对 BFC 规范(块级格式化上下文:block formatting context)的理解?

BFC 就是页面上的一个隔离的独立容器,容器里面的子元素不会影响到外面的元素;反之也如此;

W3C 对 BFC 的定义如下

> 浮动元素和绝对定位元素,非块级盒子的块级容器(例如 inline-blocks, table-cells, 和 table-captions),以及 overflow 值不为"visiable"的块级盒子,都会为他们的内容创建新的 BFC(块级格式上下文);

为了便于理解,我们换一种方式来重新定义 BFC;一个 HTML 元素要创建 BFC,则满足下列的任意一个或多个条件即可

1、float 的值不是 none;

2、position 的值不是 static 或者 relative;

3、display 的值是 inline-block、table-cell、flex、table-caption 或者 inline-flex

4、overflow 的值不是 visible

5、根元素

BFC 是一个独立的布局环境,其中的元素布局是不受外界的影响,并且在一个 BFC 中,块盒与行盒(行盒由一行中所有的内联元素所组成)都会垂直的沿着其父元素的边框排列;

[什么是 BFC?看这一篇就够了](https://blog.csdn.net/sinat_36422236/article/details/88763187)

[什么是 BFC?](https://www.jianshu.com/p/0d713b32cd0d)

[什么是 BFC?什么条件下会触发?应用场景有哪些?](http://47.98.159.95/my_blog/css/008.html)

[块格式化上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)

#### 41.css 定义的权重

- 以下是权重的规则:标签的权重为 1,class 的权重为 10,id 的权重为 100

- 如果权重相同,则最后定义的样式会起作用,但是应该避免这种情况出现

#### 42.请解释一下为什么需要清除浮动?清除浮动的方式

```css
/* 清除浮动是为了清除使用浮动元素产生的影响.浮动的元素,高度会塌陷,而高度的塌陷使我们页面后面的布局不能正常显示. */

/* 1、父级 div 定义 height; */

/* 2、父级 div 也一起浮动; */

/* 3、常规的使用一个 class; */

.clearfix::before,
.clearfix::after {
  content: ' ';
  display: table;
}

.clearfix::after {
  clear: both;
}

.clearfix {
  \*zoom: 1;
}

/* 4、SASS 编译的时候,浮动元素的父级 div 定义伪类:after */

&::after,
&::before {
  content: ' ';
  visibility: hidden;
  display: block;
  height: 0;
  clear: both;
}
```

- 解析原理:

  1. display:block 使生成的元素以块级元素显示,占满剩余空间;

  2. height:0 避免生成内容破坏原有布局的高度.

  3. visibility:hidden 使生成的内容不可见,并允许可能被生成内容盖住的内容可以进行点击和交互;

  4. 通过 content:"."生成内容作为最后一个元素,至于 content 里面是点还是其他都是可以的,例如 oocss 里面就有经典的 content:".",有些版本可能 content 里面内容为空,一丝冰凉是不推荐这样做的,firefox 直到 7.0 content:"" 仍然会产生额外的空隙;

  5. zoom:1 触发 IE hasLayout.

- 通过分析发现,除了 clear:both 用来闭合浮动的,其他代码无非都是为了隐藏掉 content 生成的内容,这也就是其他版本的闭合浮动为什么会有 font-size:0,line-height:0.

[CSS 浮动? 如何清除浮动?](https://www.jianshu.com/p/4d0bc8776122)

[清除浮动的最常用的四种方法,以及优缺点](https://blog.csdn.net/h_qingyi/article/details/81269667)

[clear](https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear)

#### 43.什么是外边距合并?

- 外边距合并指的是,当两个垂直外边距相遇时,它们将形成一个外边距.

- 合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者.

[外边距重叠](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing)

#### 44.zoom:1 的清除浮动原理?

- zoom CSS 属性会根据 @viewport 来初始化一个缩放因数;

- 当设置 1.0 或 100%时表示不缩放;更大的值放大,更小的值缩小;

- 当设置了 zoom 的值之后,所设置的元素就会就会扩大或者缩小,高度宽度就会重新计算了,这里一旦改变 zoom 值时其实也会发生重新渲染,运用这个原理,也就解决了 ie 下子元素浮动时候父元素不随着自动扩大的问题.

- Firefox Safari 不兼容

#### 45.移动端的布局用过媒体查询吗?

```html
<!-- 假设你现在正用一台显示设备来阅读这篇文章,同时你也想把它投影到屏幕上,或者打印出来, -->

<!-- 而显示设备、屏幕投影和打印等这些媒介都有自己的特点,CSS 就是为文档提供在不同媒介上展示的适配方法 -->

<!-- link元素中的CSS媒体查询 -->

<!-- 当媒体查询为真时,相关的样式表或样式规则会按照正常的级联规被应用. -->

<!-- 当媒体查询返回假, <link> 标签上带有媒体查询的样式表 仍将被下载 (只不过不会被应用). -->

<link rel="stylesheet" media="(max-width: 800px)" href="example.css" />

<!-- 样式表中的CSS媒体查询 -->

<!-- 包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式. -->

<!-- CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围. -->

<style>
  @media (min-width: 700px) and (orientation: landscape) {
    .sidebar {
      display: none;
    }
  }
</style>
```

[@media](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media)

[orientation](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@viewport/orientation)

#### 46.使用 CSS 预处理器吗?喜欢那个?

- SASS (SASS、LESS、stylus 没有本质区别,团队统一用一个就好)

#### 47.CSS 优化、提高性能的方法有哪些?

- 加载性能

  主要是从减少文件体积,减少阻塞加载,提高并发方面入手

  打包合并 css 文件

- 选择器性能

  不要在 ID 选择器前面进行嵌套,ID 本来就是唯一的而且人家权值那么大,嵌套完全是浪费性能;

- 渲染性能

  不用 css 表达式,表达式只是让你的代码显得更加炫酷,但是他对性能的浪费可能是超乎你的想象的;

- 可维护性

  建立公共样式类,把相同样式提取出来作为公共类使用,比如我们常用的清除浮动等;

  使用预处理工具或构建工具(gulp 对 css 进行语法检查、自动补前缀、打包压缩、自动优雅降级);

- 拆分出公共 css 文件,对于比较大的项目我们可以将大部分页面的公共结构的样式提取出来放到单独 css 文件里, 这样一次下载后就放到缓存里,当然这种做法会增加请求,具体做法应以实际情况而定;

#### 48.浏览器是怎样解析 CSS 选择器的?

- 样式系统从关键选择器开始匹配,然后左移查找规则选择器的祖先元素.

- 只要选择器的子树一直在工作,样式系统就会持续左移,直到和规则匹配,或者是因为不匹配而放弃该规则.

- 简单的来说浏览器从右到左进行查找的好处是为了尽早过滤掉一些无关的样式规则和元素

- 叶节点向上

[CSS 渲染原理以及优化策略](https://segmentfault.com/a/1190000021073560)

#### 49.在网页中的应该使用奇数还是偶数的字体?为什么呢?

- 偶数字号相对更容易和 web 设计的其他部分构成比例关系

[谈谈网页中使用奇数字体和偶数字体](https://blog.csdn.net/jian_xi/article/details/79346477)

#### 50.margin 和 padding 分别适合什么场景使用?

- margin 是用来隔开元素与元素的间距;padding 是用来隔开元素与内容的间隔;

- margin 用于布局分开元素使元素与元素互不相干;

- padding 用于元素与内容之间的间隔,让内容(文字)与(包裹)元素之间有一段间距

#### 51.元素竖向的百分比设定是相对于容器的高度吗?

对于竖直方向的 margin 和 padding,参照父元素的宽度.(不一定)

对于水平方向的 margin 和 padding,也是参照父元素的宽度.(不一定)

[元素竖向的百分比设定是相对于容器的高度吗?](https://www.jianshu.com/p/270db39f6ddd)

[CSS 中 margin-top/bottom(padding-top/bottom)百分比为何以最近的块级祖先元素的宽度而不是高度作计算](https://www.zhihu.com/question/20983035)

#### 52.抽离样式模块怎么写,说出思路,有无实践经验?[阿里航旅的面试题]

把公共的样式抽离出来 id class 直接用

#### 53.全屏滚动的原理是什么?用到了 CSS 的那些属性?

[全屏滚动的原理是什么用到了 css 的哪些属性??(笔试题)](https://blog.csdn.net/yehaocheng520/article/details/105611762/)

#### 54.什么是响应式设计?响应式设计的基本原理是什么?如何兼容低版本的 IE?

- 答:一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本.

- 优点:

  面对不同分辨率设备灵活性强

  能够快捷解决多设备显示适应问题

- 缺点:

  兼容各种设备工作量大,效率低下

  代码累赘,会出现隐藏无用的元素,加载时间加长

  其实这是一种折中性质的设计解决方案,多方面因素影响而达不到最佳效果

  一定程度上改变了网站原有的布局结构,会出现用户混淆的情况

  respond.js 和 css3-mediaqueries-js

#### 55.视差滚动效果,如何给每页做不同的动画?(回到顶部,向下滑动要再次出现,和只出现一次分别怎么做?)

- 这种技术通过在网页向下滚动的时候,控制背景的移动速度比前景的移动速度慢来创建出令人惊叹的 3D 效果.

- 原理:

  (1)CSS3 实现

  优点:开发时间短、性能和开发效率比较好,缺点是不能兼容到低版本的浏览器

  (2)jquery 实现

  通过控制不同层滚动速度,计算每一层的时间,控制滚动效果.

  优点:能兼容到各个版本的,效果可控性好

  缺点:开发起来对制作者要求高

  (3)插件实现方式

  例如:parallax-scrolling,兼容性十分好

#### 56.::before 和 :after 中双冒号和单冒号 有什么区别?解释一下这 2 个伪元素的作用.

- 单冒号(:)用于 CSS3 伪类,双冒号(::)用于 CSS3 伪元素.(伪元素由双冒号和伪元素名称组成)

- 双冒号是在当前规范中引入的,用于区分伪类和伪元素.不过浏览器需要同时支持旧的已经存在的伪元素写法,

- 比如:first-line、:first-letter、:before、:after 等,

- 而新的在 CSS3 中引入的伪元素则不允许再支持旧的单冒号的写法.

- 想让插入的内容出现在其它内容前,使用::before,否者,使用::after;

- 在代码顺序上,::after 生成的内容也比::before 生成的内容靠后.

- 如果按堆栈视角,::after 生成的内容会在::before 生成的内容之上

[伪元素&伪类](https://www.jianshu.com/p/8b610fdf0d48)

#### 57.如何修改 chrome 记住密码后自动填充表单的黄色背景 ?

```css
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
  background-color: rgb(250, 255, 189); /* #FAFFBD; */
  background-image: none;
  color: rgb(0, 0, 0);
}
```

#### 58.你对 line-height 是如何理解的?

[「line-height」深入理解](https://www.jianshu.com/p/04432ef9d4c0)

#### 59.设置元素浮动后,该元素的 display 值是多少?

自动变成了 display:block

在项目中如果需要设置行内元素的宽高,则设置为浮动后,就可以设置了

#### 60.怎么让 Chrome 支持小于 12px 的文字?

1. 用图片:如果是内容固定不变情况下,使用将小于 12px 文字内容切出做图片,这样不影响兼容也不影响美观.

2. 使用 12px 及 12px 以上字体大小:为了兼容各大主流浏览器,建议设计美工图时候设置大于或等于 12px 的字体大小,如果是接单的这个时候就需要给客户讲解小于 12px 浏览器不兼容等事宜.

3. 继续使用小于 12px 字体大小样式设置:如果不考虑 chrome 可以不用考虑兼容,同时在设置小于 12px 对象设置-webkit-text-size-adjust:none,做到最大兼容考虑.

4. 使用 12px 以上字体:为了兼容、为了代码更简单 从新考虑权重下兼容性.

#### 61.让页面里的字体变清晰,变细用 CSS 怎么做?

```css
body {
  -webkit-font-smoothing: antialiased;
}
```

[字体平滑](https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-smooth)

尽管在早期(2002)的 CSS3 Fonts 草稿中就出现了 font-smooth ,但是这个属性已经在规范中被移除,而且已经不在标准跟踪之中;

[1] Webkit 实现了名为-webkit-font-smoothing 的相似属性;这个属性仅在 Mac OS X/macOS 下生效;

[2] Firefox 实现了名为 -moz-osx-font-smoothing 的相似属性;这个属性仅在 Mac OS X / macOS 下生效;

#### 62.font-style 属性可以让它赋值为"oblique" oblique 是什么意思?

- 倾斜的字体样式

[font-style](https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-style)

#### 63.position:fixed;在 android 下无效怎么处理?

- fixed 的元素是相对整个页面固定位置的,你在屏幕上滑动只是在移动这个所谓的 viewport,

- 原来的网页还好好的在那,fixed 的内容也没有变过位置,

- 所以说并不是 iOS 不支持 fixed,只是 fixed 的元素不是相对手机屏幕固定的.

```html
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"
/>
```

#### 64.如果需要手动写动画,你认为最小时间间隔是多久,为什么?(阿里)

- 多数显示器默认频率是 60Hz,即 1 秒刷新 60 次,所以理论上最小间隔为 1/60＊1000ms ＝ 16.7ms

#### 65.display:inline-block 什么时候会显示间隙?(携程)

- 移除空格、使用 margin 负值、使用 font-size:0、letter-spacing、word-spacing

#### 66.overflow: scroll 时不能平滑滚动的问题怎么处理?

[iOS 问题](https://www.jianshu.com/p/1f4693d0ad2d)

#### 67.有一个高度自适应的 div,里面有两个 div,一个高度 100px,希望另一个填满剩下的高度.

- 方法一、 flex 方法

  实现原理该方法主要部分就是使用了 flex:1 属性来实现 box2 的自动伸缩

  注意点注意兼容性

- 方法二 、绝对定位方法

  实现原理 box2 采用 absolute

  绝对定位后,再使用 bottom:0 属性,会使得其紧贴其包裹的元素的底部;

  (准确说是其含有 position:relative 的父级或以上的包裹元素 )

  注意点父级元素别忘记使用 position:relative,否则将定位至 html 上

- 方法三、 calc 方法

  实现原理就是通过计算结果设置高度 注意点注意兼容性

- 方法四、 grid 方法

  实现原理利用网格布局中的 fr 单位 注意点注意兼容性

- 方法五 、border-box + 绝对定位方法

  实现原理由于父元素被设置成了 IE 盒模型,且父元素的 padding-top 与子元素 box1 的高度是一样的,

  因此绝对定位的子元素 box1 属性设为 top:0 时,其自然而然就处于父元素的 padding-top 区域了;

  (高度相等 正好遮盖 padding-top),而非绝对定位的子元素 box2 的高度设为 100%时,

  其高度就是父元素盒模型中的 content 里的高度(不包含 padding 及 margin 值),因此正好也就填充了

  剩余空间了; 注意点父元素记得设置 position:relative 及 box-sizing:border-box

- 方法六 border-box + 负 margin 方法

  实现原理有部分跟方法五有点类似,都是设置父元素为 IE 盒模型,且其 padding-top 为 100px,

  非绝对定位的子元素 box2 高度为 100%;负 margin-top 的子元素 box1 为 100px,导致其会整体上移 100px,

  也就正好遮挡了父元素的 padding-top 部分了;

  注意点父元素记得设置 box-sizing:border-box

#### 68.png、jpg、gif 这些图片格式解释一下,分别什么时候用.有没有了解过 webp?

- SVG(无损压缩、支持动画)

  1. 矢量图形,文件比较小,同时也能提供高清晰的画面,适合于直接打印或输出;

  2. 图像文件可读,易于修改和编辑;

  3. 可以方便的创建文字索引,从而实现基于内容的图像搜索;

  4. 可以用来动态生成图形;也可以与现有技术可以互动融合;

- JPEG(有损/无损)

  1. 支持渐进传输,传输过程中图片从模糊到清晰;

  2. 支援高动态范围成像、支援图片透明度;

- GIF (无损压缩、支持动画、8 位压缩最多处理 256 种颜色)

  1. 优秀的压缩算法使其在一定程度上保证图像质量的同时将体积变得很小;

  2. 可插入多帧,从而实现动画效果;

  3. 可设置透明色以产生对象浮现于背景之上的效果;

- PNG(无损压缩)

  1. 分为 8 位,24 位,32 位;其中 PNG24 不支持透明;

  2. 渐进显示和流式读写;

  3. 保留图像名称、作者、版权、创作时间;

- 通俗理解有损压缩和无损压缩有损压缩删除了不易被人眼察觉的颜色细节,减少了图片在内存和磁盘上的占用空间;无损压缩则首先记录图片的那些颜色是相同的,哪些颜色是不同的,然后压缩相同的颜色,减少了磁盘占用空间,但是不能减少内存占用量——这是因为当从磁盘读取图片时,丢失的颜色都会被填回来;如果要减少图片内存占用量就必须用有损压缩方法;

[img](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img)

[webp 在项目中的实践](https://www.jianshu.com/p/73ca9e8b986a)

#### 69. 什么是 Cookie 隔离?(或者说:请求资源的时候不要让它带 cookie 怎么做)

- 如果静态文件都放在主域名下,那静态文件请求的时候都带有的 cookie 的数据提交给 server 的,非常浪费流量,所以不如隔离开.

- 因为 cookie 有域的限制,因此不能跨域提交请求,故使用非主要域名的时候,请求头中就不会带有 cookie 数据,这样可以降低请求头的大小,降低请求时间,从而达到降低整体请求延时的目的.

- 同时这种方式不会将 cookie 传入 Web Server,也减少了 Web Server 对 cookie 的处理分析环节,提高了 webserver 的 http 请求的解析速度.

#### 70.style 标签写在 body 后与 body 前有什么区别?

1. 写在 body 标签前利于浏览器逐步渲染

   resources downloading->CSSOM+DOM->RenderTree(composite)->Layout->paint

2. 写在 body 标签后

   由于浏览器以逐行方式对 html 文档进行解析;

   当解析到写在尾部的样式表(外联或写在 style 标签)会导致浏览器停止之前的渲染,等待加载且解析样式表完成之后重新渲染;

   在 windows 的 IE 下可能会出现 FOUC 现象(即样式失效导致的页面闪烁问题);

#### 71.什么是 CSS 预处理器 / 后处理器?

- 预处理器例如:LESS、Sass、Stylus,用来预编译 Sass 或 less,增强了 css 代码的复用性,

  还有层级、mixin、变量、循环、函数等,具有很方便的 UI 组件模块化开发能力,极大的提高工作效率.

- 后处理器例如:PostCSS,通常被视为在完成的样式表中根据 CSS 规范处理 CSS,让其更有效;目前最常做的

  是给 CSS 属性添加浏览器私有前缀,实现跨浏览器兼容性的问题.

#### 72.rem 布局的优缺点

[Rem 布局的原理解析](https://www.jianshu.com/p/09bd0ca51ef5)

#### 73. canvas 与 SVG 之间的一些不同之处;

- Canvas

  - 依赖分辨率

  - 不支持事件处理器

  - 弱的文本渲染能力

  - 能够以 .png 或 .jpg 格式保存结果图像

  - 最适合图像密集型的游戏,其中的许多对象会被频繁重绘

  - Canvas 是逐像素进行渲染的;

  - 在 canvas 中,一旦图形被绘制完成,它就不会继续得到浏览器的关注;如果其位置发生变化,那么整个场景也需要重新绘制,包括任何或许已被图形覆盖的对象;

- SVG

  - 不依赖分辨率

  - 支持事件处理器

  - 最适合带有大型渲染区域的应用程序(比如谷歌地图)

  - 复杂度高会减慢渲染速度(任何过度使用 DOM 的应用都不快)

  - 不适合游戏应用

#### 74.displaynone 与 visibilityhidden

- displaynone 指的是元素完全不陈列出来,不占据空间,涉及到了 DOM 结构,故产生 reflow 与 repaint

- visibilityhidden 指的是元素不可见但存在,保留空间,不影响结构,故只产生 repaint

#### 75.Web Worker

> 通过使用 Web Workers，Web 应用程序可以在独立于主线程的后台线程中，运行一个脚本操作。这样做的好处是可以在独立线程中执行费时的处理任务，从而允许主线程(通常是 UI 线程)不会因此被阻塞/放慢。

> 除了专用 worker(dedicate worker) 之外，还有一些其他种类的 worker ：

- Shared Workers 可被不同的窗体的多个脚本运行，例如 IFrames 等，只要这些 workers 处于同一主域。共享 worker 比专用 worker 稍微复杂一点 — 脚本必须通过活 动端 口进行通讯。详情请见 SharedWorker。

- Service Workers 一般作为 web 应用程序、浏览器和网络(如果可用)之间的代理服务。他们旨在(除开其他方面)创建有效的离线体验，拦截网络请求，以及根据网 络是 否可用采取合适的行动，更新驻留在服务器上的资源。他们还将允许访问推送通知和后台同步 API。

- Chrome Workers 是一种仅适用于 firefox 的 worker。如果您正在开发附加组件，希望在扩展程序中使用 worker 且可以访问 js-ctypes，那么可以使用 Chrome Workers。详情请见 ChromeWorker

- 音频 Workers 可以在网络 worker 上下文中直接完成脚本化音频处理.

[Web Workers API](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API)

#### 76.Service Worker,Web Worker,WebSocket 的对比

- Service Worker

  处理网络请求的后台服务。适用于离线和后台同步数据或推送信息。不能直接和 dom 交互。通过 postMessage 方法交互。

- Web Worker

  模拟多线程，允许复杂计算功能的脚本在后台运行而不会阻碍到其他脚本的运行。适用于处理器占用量大而又不阻碍的情形。不能直接与 dom 交互。通过 postMessage 方法交互。

- WebSocket

  在客户端和服务端之间建立保持双向通信的连接。适用于需要保持长推送的情形，如聊天应用，在线游戏或运动直播等。不能直接与 dom 交互。通过 send 方法交互。

- 参考:

  1. [Service Worker,Web Worker,WebSocket 的对比](https://www.cnblogs.com/Hard/p/Service_Worker-Web_Worker-WebSocket-comparation.html)

  2. [区别 Web Socket、Web Worker 和 Service Worker](https://blog.csdn.net/weixin_44156420/article/details/90183884)

#### 77.常见的 DOM 操作

1. 查找节点

```js
document.getElementById('id属性值') //返回拥有指定id的第一个对象的引用

document / element.getElementsByClassName('class属性值') //返回拥有指定class的对象集合

document / element.getElementsByTagName('标签名') //返回拥有指定标签名的对象集合

document.getElementsByName('name属性值') //返回拥有指定名称的对象结合

document / element.querySelector('CSS选择器') //仅返回第一个匹配的元素

document / element.querySelectorAll('CSS选择器') //返回所有匹配的元素

document.documentElement //获取页面中的HTML标签

document.body //获取页面中的BODY标签

document.all[''] //获取页面中的所有元素节点的对象集合型
```

2. 创建节点

```js
document.createElement('元素名') // 创建新的元素节点

document.createAttribute('属性名') // 创建新的属性节点

document.createTextNode('文本内容') // 创建新的文本节点

document.createComment('注释节点') // 创建新的注释节点

document.createDocumentFragment() // 创建文档片段节点
```

3. 删除节点

```js
parentNode.removeChild(existingChild) // 删除已有的子节点，返回值为删除节点

element.removeAttribute('属性名') // 删除具有指定属性名称的属性，无返回值

element.removeAttributeNode(attrNode) // 删除指定属性，返回值为删除的属性
```

4. 修改节点

```js
parentNode.replaceChild(newChild, existingChild) // 用新节点替换父节点中已有的子节点

element.setAttributeNode(attributeName) // 若原元素已有该节点，此操作能达到修改该属性值的目的

element.setAttribute(attributeName, attributeValue) // 若原元素已有该节点，此操作能达到修改该属性值的目的
```

5. 插入节点

```js
parent.appendChild(element / txt / comment / fragment) // 向父节点的最后一个子节点后追加新节点

parent.insertBefore(newChild, existingChild) // 向父节点的某个特定子节点之前插入新节点

element.setAttributeNode(attributeName) // 给元素增加属性节点

element.setAttribute(attributeName, attributeValue) // 给元素增加指定属性，并设定属性值
```

6. 设置样式

```js
ele.style.styleName = styleValue //设置ele元素的CSS样式
```

[Document](https://developer.mozilla.org/zh-CN/docs/Web/API/Document)

[Node](https://developer.mozilla.org/zh-CN/docs/Web/API/Node)

[Element](https://developer.mozilla.org/zh-CN/docs/Web/API/Element)

[Element 和 Node 的区别你造吗？](https://www.jianshu.com/p/695b5c78a7ca)

[DOM 中的 node 与 element 的区别](https://www.cnblogs.com/gentlemint/p/5476742.html)

## 前端框架

### vue

#### 1.axios 是什么?怎么使用?描述使用它实现登录功能的流程?

- axios 是基于 promise 用于浏览器和 nodeJs 的一个 http 客户端,主要用于向后端发起请求 在请求中做更多的控制

- 支持 promise

- 提供了一些并发的方法

- 提供了拦截器

- 提供支持 CSRF(跨站请求伪造)

- axios fetch ajax 区别

- 前俩者都是支持 promise 语法 后置使用回调 callback

- fetch 本质上脱离 xhr 是新的语法(有自己的特性 默认不传 cookie 不能像 xhr 监听请求的进度)

#### 2.vuex 是什么?怎么使用?哪种功能场景使用它?

- Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式.它采用集中式存储管理应用的所有组件的状态,并以相应的规则保证状态以一种可预测的方式发生变化.

[Vuex](https://vuex.vuejs.org/zh/)

[?](http://www.imooc.com/article/284778)

#### 3.常用指令与自定义指令怎么做

- v-if v-show v-for v-model v-html

- v-bind :

- v-on @

- v-bind 和 v-model 的区别简单来说,区别如下

  1. v-bind 用来绑定数据和属性以及表达式,缩写为''

  2. v-model 使用在表单中,实现双向数据绑定的,在表单元素外使用不起作用

- 自定义指令:

  ```javascript
  // 创建局部指令
  var app = new Vue({
    el: '#app',
    data: {},
    // 创建指令
    directives: {
      // 指令名称
      dir1: {
        //钩子函数
        inserted(el) {
          // 指令中的第一个参数是当前使用指令的 DOM
          console.log(el)
          console.log(arguments)
          // 对DOM进行操作
          el.style.width = '200px'
          el.style.height = '200px'
          el.style.background = '#ccc'
        },
      },
    },
  })
  // 全局指令
  Vue.directive('dir2', {
    inserted(el) {
      console.log(el)
    },
  })
  ```

- 钩子函数 inserted 被绑定元素插入父节点时调用 (仅保证父节点存在,但不一定已被插入文档中);

- 指令的使用

  ```html
  <!-- 指令的使用 -->
  <div>
    <div v-dir1 />
    <div v-dir2 />
  </div>
  ```

- 其他钩子函数详见官方文档.

  [自定义指令](https://cn.vuejs.org/v2/guide/custom-directive.html)

#### 4.导航钩子 路由

- vue-router

- 路由跳转前做一些验证,比如登录验证,是网站中的普遍需求;对此,vue-route 提供的 beforeRouteUpdate 可以方便地实现导航守卫;

- 全局钩子函数

  - beforeEach :在路由切换时开始调用

  - afterEach:在路由切换离开时调用

- 局部到单个路由

  - beforeEnter

- 组件的钩子函数

  - beforeRouterEnter

  - beforeRouterUpdate

  - beforeRouterLeave

- 参数:to from next

```javascript
// 全局守卫例子

// 你可以使用 router.beforeEach 注册一个全局前置首位

const router = new VueRouter({ ... })

router.beforeEach(( to, from, next ) => {

  // doSomething...

})

//每个守卫接收三个参数:

/*
to: Route 即将要进入的目标路由对象

from: Route 当前导航正要离开的路由对象

next: Function 一定要调用 next() 方法来 resolve 这个钩子,执行效果依赖 next() 方法的调用参数;确保要调用这个方法,否则钩子就不会被 resolved.
*/

/*
一个应用场景

1.列举需要判断登录状态的"路由集合",当跳转至集合中的路由时,如果"未登录状态",则跳转到登录页面LoginPage;

2.当直接进入登录页面LoginPage时,如果"已登录状态",则跳转到首页HomePage;
*/

/*
- hash 模式在浏览器中符号"#",#以及#后面的字符称之为 hash,用 window.location.hash 读取; 特点 hash 虽然在 URL 中,但不被包括在 HTTP 请求中;用来指导浏览器动作,对服务端安全无用,hash 不会重加载页面; hash 模式下,仅 hash 符号之前的内容会被包含在请求中,如 http://www.xxx.com,因此对于后端来说,即使没有做到对路由的全覆盖,也不会返回 404 错误;

- history 模式 history 采用 HTML5 的新特性;且提供了两个新方法 pushState(),replaceState()可以对浏览器历史记录栈进行修改,以及 popState 事件的监听到状态变更; history 模式下,前端的 URL 必须和实际向后端发起请求的 URL 一致,如 http://www.xxx.com/items/id;后端如果缺少对 /items/id 的路由处理,将返回 404 错误;Vue-Router 官网里如此描述"不过这种模式要玩好,还需要后台配置支持……所以呢,你要在服务端增加一个覆盖所有情况的候选资源如果 URL 匹配不到任何静态资源,则应该返回同一个 index.html 页面,这个页面就是你 app 依赖的页面;"
*/
```

[Vue Router](https://router.vuejs.org/zh/)

#### 5.插槽

- 写一些通用组件需要用到插槽

- slot

- 匿名插槽

- 具名插槽 v-slot: 缩写 # 插槽 slot name

- 作用域插槽

```html
<!-- current-user -->

<span>
  <slot v-bind:user="user">
    {{ user.lastName }}
  </slot>
</span>

<!-- 一般使用 -->

<current-user>
  <template v-slot:default="slotProps">
    {{ slotProps.user.firstName }}
  </template>
</current-user>

<!-- 上面的简化default -->

<current-user v-slot="slotProps">
  {{ slotProps.user.firstName }}
</current-user>

<!-- 使用解构 -->

<current-user v-slot="{ user }">
  {{ user.firstName }}
</current-user>

<!-- 使用结构重命名 -->

<current-user v-slot="{ user: person }">
  {{ person.firstName }}
</current-user>

<!-- 使用结构 后备内容 -->

<current-user v-slot="{ user = { firstName: 'Guest' } }">
  {{ user.firstName }}
</current-user>
```

- 父级模板里的所有内容都是在父级作用域中编译的;子模板里的所有内容都是在子作用域中编译的;

[插槽](https://cn.vuejs.org/v2/guide/components-slots.html)

#### 6.虚拟 dom

- DOM 的本质: DOM 是浏览器概念,浏览器从服务器端读取 html 页面,浏览器讲 html 解析成一个元素嵌套关系的 DOM 树,用对象来表示页面上的元素,并提供操作 DOM 对象的 API

- 虚拟 DOM: 框架概念,用 js 对象来模拟页面上 DOM 元素的嵌套关系,为了实现页面元素的高效更新;虚拟 DOM 是真实 DOM 结构的映射,即一个数据集合;虚拟 DOM 的核心就是一个 diff 算法:使用一个 render()方法就可以将上面 vNodes 还原成真实的 Html 页面

#### 7.组件间的传值

常见使用场景可以分为三类

- 父子通信

  父向子传递数据是通过 props,子向父是通过 events($emit/$on);通过父链 / 子链也可以通信($parent / $children);ref 也可以访问组件实例;provide / inject ;$attrs / $listeners

- 兄弟通信

  Bus;Vuex

- 跨级通信

  Bus;Vuex;provide / inject API、$attrs/$listeners

详细点--------->

- $parent $children ref

- provide inject (主要解决了跨级组件间的通信问题,不过它的使用场景,主要是子组件获取上级组件的状态,跨级组件间建立了一种主动提供与依赖注入的关系。)
  provide 提供的数据不是可响应的 方法一:provide 提供祖先组件 this 实列 方法二:使用 Vue.observable() Api 包裹数据

- $attrs $listeners
  简单来说$attrs与$listeners 是两个对象,$attrs 里存放的是父组件中绑定的非 Props 属性 (class 和 style 除外),通常配合 inheritAttrs 选项一起使用。$listeners 里存放的是父组件中绑定的非原生事件。

- Vuex state getters mutations actions (dispacth commit)

- $emit $on (Bus)

- props \$emit

详细点 end-------->

[Vue 组件间通信六种方式(完整版)](https://juejin.im/post/5cde0b43f265da03867e78d3?utm_source=gold_browser_extension)

[vue2.0 学习](https://github.com/ljianshu/Blog/tree/master/vue2.0%E5%AD%A6%E4%B9%A0)

#### 8.Vue 双向绑定原理

- vue2 采用 数据劫持 结合 发布者-订阅者模式的方式,通过 Object.defineProperty()来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发相应的监听回调;

1. 实现一个数据监听器 Observer,能够对数据对象的所有属性进行监听,如有变动可拿到最新值并通知订阅者

2. 实现一个指令解析器 Compile,对每个元素节点的指令进行扫描和解析,根据指令模板替换数据,以及绑定相应的更新函数

3. 实现一个 Watcher,作为连接 Observer 和 Compile 的桥梁,能够订阅并收到每个属性变动的通知,执行指令绑定的相应回调函数,从而更新视图

4. mvvm 入口函数,整合以上三者

- else: vue3 数据劫持的方式由 Object.defineProperty 更改为 Proxy 代理

[mvvm](https://github.com/DMQ/mvvm)

#### 9.Vue 的生命周期和钩子函数

[Vue2.0 探索之路——生命周期和钩子函数的一些理解](https://segmentfault.com/a/1190000008010666)

#### 10.应该在 vue 的生命周期的什么阶段发出 ajax 请求,为什么

- 看实际情况,一般在 created 里面就可以,如果涉及到需要页面加载完成之后的话就用 mounted

#### 11.Vue 登录流程?需要做什么验证?

在前后端完全分离的情况下,Vue 项目中实现 token 验证大致思路如下

1. 第一次登录时,前端调用后端登录接口,发送用户名和密码

2. 后端接收到请求,验证用户名和密码,验证成功,返回给前端一个 token

3. 前端拿到 token, 将 token 存储到 localStroage 和 vuex 中,并跳转路由页面

4. 前端每次在跳转路由时,判断 localStroage 中有无 token, 没有就跳转到登录页面,有就跳转到对应路由页面

5. 之后每次调用后端接口,都要在请求头中添加 token,我们常用 axios 的全局拦截器

6. 后端判断请求头中有无 token,有就验证,验证成功返回数据;没有或者验证失败(token 过期)返回 401 或其他 code

7. 前端判断 code 若为 401,清除 stroage 和 vuex 中 token 信息 并跳转到登录叶面

```javascript
// http request 拦截器

axios.interceptors.request.use(
  (config) => {
    if (store.state.token) {
      // 判断是否存在token,如果存在的话,则每个http header都加上token
      config.headers.Authorization = `token ${store.state.token}`
    }
    return config
  },
  (err) => {
    return Promise.reject(err)
  }
)

// http response 拦截器

axios.interceptors.response.use(
  (response) => {
    return response
  },
  (error) => {
    if (error.response) {
      switch (error.response.status) {
        case 401:
          // 返回 401 清除token信息并跳转到登录页面
          store.commit(types.LOGOUT)
          router.replace({
            path: 'login',
            query: { redirect: router.currentRoute.fullPath },
          })
      }
    }
    return Promise.reject(error.response.data) // 返回接口返回的错误信息
  }
)

// error 拦截器
```

#### 12.讲一下 MVVM 中的 vm 工作流程

- MVVM 是 Model-View-ViewModel 的缩写;

- 其中 Model 代表数据模型,也可以在 Model 中定义数据修改和操作的业务逻辑;

- View 代表 UI 组件,它负责将数据模型转化成 UI 展现出来;

- ViewModel 监听模型数据的改变 和 控制视图行为、处理用户交互,简单理解就是一个同步 View 和 Model 的对象,连接 Model 和 View;

- 在 MVVM 架构下,view 和 model 直接并没有直接的联系,而是通过 ViewModel 进行交互;

- ViewModel 通过双向数据绑定把 View 层和 Model 层连接起来了,而 View 和 Model 之间的同步工作完全是自动的,无需人为干涉,因此,开发者只需要关注业务逻辑,不需要手动操作 DOM,不需要关注数据状态的同步问题,复杂的数据状态维护完全由 MVVM 来统一管理;

- vue.js 则是采用数据劫持结合发布者-订阅者模式的方式,通过 Object.defineProperty()来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发相应的监听回调。

[深入响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html)

[MVC,MVP 和 MVVM 的图示](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)

#### 13.Vue 和 react 的区别?

- react 和 vue 都是做组件化的,整体的功能都类似,但是他们的设计思路是有很多不同的;使用 react 和 vue,主要是理解他们的设计思路的不同

- react 整体是函数式的思想,把组件设计成纯组件,状态和逻辑通过参数传入,所以在 react 中,是单向数据流,

- 而 vue 的思想是响应式的,也就是基于是数据可变的,通过对每一个属性建立 Watcher 来监听,当属性变化的时候,响应式的更新对应的虚拟 dom

- react 的性能优化需要手动去做,而 vue 的性能优化是自动的,但是 vue 的响应式机制也有问题,就是当 state 特别多的时候,Watcher 也会很多,会导致卡顿

- react 是类式的写法,api 很少,而 vue 是声明式的写法,通过传入各种 options,api 和参数都很多

- react 可以通过高阶组件(Higher Order Components--HOC)来扩展,而 vue 需要通过 mixins 来扩展

- 总结 react 整体的思路就是函数式,所以推崇纯组件,数据不可变,单向数据流,当然需要双向的地方也可以做到,比如结合 redux-form,而 vue 是基于可变数据的,支持双向绑定;react 组件的扩展一般是通过高阶组件,而 vue 组件会使用 mixin;vue 内置了很多功能,而 react 做的很少,很多都是由社区来完成的,vue 追求的是开发的简单,而 react 更在乎方式是否正确;

[Vue 和 React 的优点分别是什么?](https://www.zhihu.com/question/301860721/answer/545031906)

#### 14.Vue-cli2.0 和 Vue-cli3.0 的区别

- 用 vue-cli3.0 版本创建的项目与 2.0 版本相比较,我们会发现,文件目录少了很多 egbuild、config,那么如何像 vue-cli 2.\* 之前关于端口号的配置、打包之后的路径的配置、图片的配置等,到哪里配置呢??vue-cli 3.0 可以在项目的根目录下新建一个 vue.config.js 文件,之前繁琐的配置都可以在这里直接配置

- 3.0 能直接运行单个组件

- 3.0 有一个 UI 管理界面 vue ui

- 安装了 2.0 版本,要先卸载

#### 15.对 keep-alive 的了解

```javascript
/* 
- <keep-alive>是Vue的内置组件,能在组件切换过程中将状态保留在内存中,防止重复渲染DOM;

<keep-alive> 包裹动态组件时,会缓存不活动的组件实例,而不是销毁它们;

<keep-alive> 与 <transition>相似,只是一个抽象组件,它不会在DOM树中渲染(真实或者虚拟都不会),也不在父组件链中存在,比如你永远在 this.$parent 中找不到 keep-alive ;

- keep-alive生命周期钩子函数activated、deactivated

使用<keep-alive>会将数据保留在内存中,如果要在每次进入页面的时候获取最新的数据,需要在activated阶段获取数据,承担原来created钩子中获取数据的任务;

被包含在 <keep-alive> 中创建的组件,会多出两个生命周期的钩子: activated 与 deactivated

activated在组件被激活时调用,在组件第一次渲染时也会被调用,之后每次keep-alive激活时被调用;

deactivated 在组件被停用时调用;

注意只有组件被 keep-alive 包裹时,这两个生命周期才会被调用,如果作为正常组件使用,是不会被调用,以及在 2.1.0 版本之后,使用 exclude 排除之后,就算被包裹在 keep-alive 中,这两个钩子依然不会被调用！另外在服务端渲染时此钩子也不会被调用的;

- 什么时候获取数据?

当引入keep-alive 的时候,页面第一次进入,钩子的触发顺序created-> mounted-> activated,退出时触发deactivated;当再次进入(前进或者后退)时,只触发activated;
*/
```

#### 16.自定义指令的生命周期

自定义指令有五个生命周期(钩子函数),分别是

- bind 值调用一次,指令第一次绑定到元素时调用,用这个钩子函数可以定义一个绑定时执行一次的初始化动作

- inserted 被绑定元素插入父节点时调用(父节点存在即可调用,不必存在与 document 中)

- update 被绑定元素所在的模板更新时调用,而无论绑定值是否变化;通过比较更新前后的绑定值,可以忽略不必要的模板更新

- componentUpdated 被绑定元素所在模板完成一次更新周期时调用(指令所在组件的 VNode 及其子 VNode 全部更新后调用;)

- unbiand 只调用一次,指令与元素解绑时调用

钩子函数的参数(el binding vnode oldVnode)

除了 el 之外,其它参数都应该是只读的,切勿进行修改;如果需要在钩子之间共享数据,建议通过元素的 dataset 来进行;

[HTMLElement.dataset](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset)

[钩子函数](https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0)

#### 17.vue 封装公共组件(通用组件)需要考虑到什么?

开发通用组件是很基础且重要的工作,通用组件必须具备高性能、低耦合的特性

1. 数据从父组件传入

   - 为了解耦,子组件本身就不能生成数据;即使生成了,也只能在组件内部运作,不能传递出去;

   - 父对子传参,就需要用到 props,但是通用组件的的应用场景比较复杂,对 props 传递的参数应该添加一些验证规则

2. 在父组件处理事件

   - 在通用组件中,通常会需要有各种事件,

   - 比如复选框的 change 事件,或者组件中某个按钮的 click 事件

   - 这些事件的处理方法应当尽量放到父组件中,通用组件本身只作为一个中转

3. 记得留一个 slot

   - 一个通用组件,往往不能够完美的适应所有应用场景

   - 所以在封装组件的时候,只需要完成组件 80% 的功能,剩下的 20% 让父组件通过 solt 解决 (即 扩展性 优先于 复用性)

4. 不要依赖 Vuex

   - 父子组件之间是通过 props 和 自定义事件 来传参,非父子组件通常会采用 Vuex 传参

   - 但是 Vuex 的设计初衷是用来管理组件状态,虽然可以用来传参,但并不推荐

   - 因为 Vuex 类似于一个全局变量,会一直占用内存

   - 在写入数据庞大的 state 的时候,就会产生内存泄露

5. 合理运用 scoped 编写 CSS

   - 在编写组件的时候,可以在 style 标签中添加 scoped,让标签中的样式只对当前组件生效

   - 但是一味的使用 scoped,肯定会产生大量的重复代码

   - 所以在开发的时候,应该避免在组件中写样式

   - 当全局样式写好之后,再针对每个组件,通过 scoped 属性添加组件样式

#### 18.父组件怎么调用子组件里的方法

```javascript
this.$refs
```

- 更多方法看组件之间的通信问题

#### 19.v-if 和 v-show 区别

- v-if 按照条件是否渲染

- v-show 是 display 的 block 或 none;

[v-if vs v-show](https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show)

#### 20.route 和 router 的区别

- route 是"路由信息对象",包括 path,params,hash,query,fullPath,matched,name 等路由信息参数;

- 而 router 是"路由实例"对象包括了路由的跳转方法,钩子函数等;

#### 21.vue.js 的两个核心是什么?

- 数据驱动

- 组件系统

#### 22.vue 常用的修饰符?

- .prevent 提交事件不再重载页面;

- .stop 阻止单击事件冒泡;

- .self 当事件发生在该元素本身而不是子元素的时候会触发;

- .capture 事件侦听,事件发生的时候会调用

- .once 点击事件将只会触发一次

- .passive

  ```js
  // passive
  /* 
  <!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --><!-- 而不会等待 `onScroll` 完成  --><!-- 这其中包含 `event.preventDefault()` 的情况  --><!-- 这个 .passive 修饰符尤其能够提升移动端的性能; --><!-- 请记住,.passive 会告诉浏览器你不想阻止事件的默认行为; -->
   */
  ```

[事件修饰符](https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6)

[v-on](https://cn.vuejs.org/v2/api/#v-on)

#### 23.v-on 可以绑定多个方法吗?

**可以**

```html
<!-- v-on绑定多个方法 -->

<!-- 对象语法 -->
<p v-on="{click:dbClick,mousemove:MouseClick}"></p>

<!-- 一个事件绑定多个函数 -->
<p @click="one(),two()">点击</p>
```

#### 24.vue 中 key 值的作用?

- 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时,它默认用"就地复用"策略;如果数据项的顺序被改变,Vue 将不会移动 DOM 元素来匹配数据项的顺序, 而是简单复用此处每个元素,并且确保它在特定索引下显示已被渲染过的每个元素;key 的作用主要是为了高效的更新虚拟 DOM;

[维护状态](https://cn.vuejs.org/v2/guide/list.html#%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81)

[key](https://cn.vuejs.org/v2/api/#key)

#### 25.什么是 vue 的计算属性?

在模板中放入太多的逻辑会让模板过重且难以维护,在需要对数据进行复杂处理,且可能多次使用的情况下,尽量采取计算属性的方式;好处

- 使得数据处理结构清晰;

- 依赖于数据,数据更新,处理结果自动更新;

- 计算属性内部 this 指向 vm 实例;

- 在 template 调用时,直接写计算属性名即可;

- 常用的是 getter 方法,获取数据,也可以使用 set 方法改变数据;

- 相较于 methods,不管依赖的数据变不变,methods 都会重新计算,但是依赖数据不变的时候 computed 从缓存中获取,不会重新计算;

#### 26.vue 等单页面应用及其优缺点

- 优点

  Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件,核心是一个响应的数据绑定系统;MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好;

- 缺点

  不支持低版本的浏览器,最低只支持到 IE9;不利于 SEO 的优化(如果要支持 SEO,建议通过服务端来进行渲染组件);第一次加载首页耗时相对长一些;不可以使用浏览器的导航按钮需要自行实现前进、后退;

#### 27.路由跳转

- 声明式(标签跳转 router-link)

- 编程式( js 跳转) this.\$router.push()

#### 28.Vue 中怎么实现跨域

- 用代理可以暂时解决本地开发时的跨域

- 真正要解决还是后端搞 cors \*

#### 28.Vue 首屏加载过慢的解决方法有哪些

**原因:**

- vue 项目作为一个单页面应用,如果不对路由进行处理,在加载首页的时候,就会将所有组件全部加载,并向服务器请求数据,这必将拖慢加载速度;

- 通过查看 Network,发现整个网站加载试讲长达 10 几秒,加载时间最长的就是 js、css 文件和媒体文件及图片

**解决办法:**

- vue-router 路由懒加载

- 在项目开发中,我们会用到很多第三方库,如果可以按需引入,我们可以只引入自己需要的组件,来减少所占空间,但也会有一些不能按需引入,我们可以采用 CDN 外部加载,在 index.html 中从 CDN 引入组件,去掉其他页面的组件 import,

- 关闭 sourcemap,sourcemap 是为了方便线上调试用的,因为线上代码都是压缩过的,导致调试极为不便,而有了 sourcemap,就等于加了个索引字典,出了问题可以定位到源代码的位置; 但是,这个玩意是每个 js 都带一个 sourcemap,有时 sourcemap 会很大,拖累了整个项目加载速度,为了节省加载时间,我们将其关闭掉

- 开启 gzip 压缩,这个优化是两方面的,前端将文件打包成.gz 文件,然后通过 nginx 的配置,让浏览器直接解析.gz 文件;

- 加个 loading 效果首页加个好看的 loading 阻塞一下,让用户别等的那么心焦;

- 如果首页真的有瓶颈,可以考虑用 node 单独做服务端渲染,而下面的子页面仍用 spa 单页的方式交互;

#### 29.vue 如何实现按需加载组件

[vue 路由懒加载及组件懒加载](https://www.cnblogs.com/-roc/p/9983177.html)

[异步组件](https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6)

#### 30.请说下封装 vue 插件封装过程

[vuejs-templates/webpack-simple](https://github.com/vuejs-templates/webpack-simple)

[vue 封装插件并发布到 npm 上](https://blog.csdn.net/applechu_lu/article/details/79329446#commentBox)

#### 31.vue 项目的多语言处理

[Vue I18n](https://kazupon.github.io/vue-i18n/zh/guide/formatting.html)

[kazupon/vue-i18n](https://github.com/kazupon/vue-i18n)

#### 32.watch

[侦听器](https://cn.vuejs.org/v2/guide/computed.html#%E4%BE%A6%E5%90%AC%E5%99%A8)

## 项目工程化

### webpack

#### 1.带你深度解锁 Webpack 系列(基础篇)

[带你深度解锁 Webpack 系列(基础篇)](https://juejin.im/post/5e5c65fc6fb9a07cd00d8838)

#### 2.带你深度解锁 Webpack 系列(优化篇)

[带你深度解锁 Webpack 系列(优化篇)](https://juejin.im/post/5e6cfdc85188254913107c1f)

#### 3.项目不知道如何做性能优化?不妨试一下代码分割

[项目不知道如何做性能优化?不妨试一下代码分割](https://juejin.im/post/5e796ec1e51d45271e2a9af9)

### NodeJS

#### 1. 使用 NodeJS 编写代码实现遍历文件夹及所有文件名

```js
const fs = require('fs')
const path = require('path')

const readDir = (entry) => {
  // fs.readdirSync(entry) 方法将返回一个包含"指定目录下所有文件名称"的数组对象.
  const dirInfo = fs.readdirSync(entry)
  // 数组遍历
  dirInfo.forEach((item) => {
    // path.join(entry, item) 将路径片段使用特定的分隔符(window:\)连接起来形成路径,并规范化生成的路径.若任意一个路径片段类型错误,会报错.
    const loacation = path.join(entry, item)
    // fs.statSync() 方法返回一个stat数组对象,包含文件或文件夹的信息;通过使用 fs.statSync(fullPath).isDirectory() 来判断是否是文件目录;
    const info = fs.statSync(location)
    if (info.isDirectory()) {
      console.log(`dir:${location}`)
      // 递归的思想！！！
      readDir(location)
    } else {
      console.log(`file:${location}`)
    }
  })
}

readDir(__dirname)
```

#### 2. 为什么学 Node?Node 如何做版本的升级?为什么要使用 nvm?

- 为什么学 Node?前端工程化---打包工具 webpack---包管理工具 npm

- 为什么要升级?webpack 基于 node api,node 升级, 打包速度提升

- nvm 苹果使用

- nvm for windows 升级 在安装目录执行操作 nvm ls ; nvm install v12.1212(node 版本号).... ;nvm use 版本号

- linux 下可使用 n node 版本管理工具

[n](https://www.npmjs.com/package/n)

#### 3. package.lock 、 yarn.lock

- 版本锁定

#### 4. pm2 进程管理完成后端环境的搭建

- PM2 是守护进程管理器 node

- pm2 start

[PM2](https://pm2.keymetrics.io/)

[Unitech/pm2](https://github.com/Unitech/pm2)

#### 5. 模块化的差异

```js
//  https://github.com/mqyqingfeng/Blog/issues/108
//  AMD、CMD、CommonJs、ES6 的对比,
//  他们都是用于在模块化定义中使用的,
//  AMD、CMD、CommonJs 是 ES5 中提供的模块化编程的方案,
//  import/export 是 ES6 中定义新增的

//  最明显的区别就是在模块定义时对依赖的处理不同

// 1、AMD 推崇依赖前置,在定义模块的时候就要声明其依赖的模块
//c.js
define(['a.js','b.js',...], function(a,b) {});
// 2、CMD 推崇就近依赖,只有在用到某个模块的时候再去 require
//c.js
var a = require(a.js);
var b = require(b.js);
// 上面俩个 可以动态引入
// webpack 使用 静态的引入 import a from 'a' 的  esmodule
```

- 在上节,我们说了这样一句话 requirejs 为全局添加了 define 函数,你只要按照这种约定的方式书写这个模块即可。
  那这个约定的书写方式是指什么呢?指的便是 The Asynchronous Module Definition (AMD) 规范。
  所以其实 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
  你去看 AMD 规范 的内容,其主要内容就是定义了 define 函数该如何书写,只要你按照这个规范书写模块和依赖,require.js 就能正确的进行解析。

- AMD(RequireJS) 浏览器 非同步加载模块,允许指定回调函数。

- CMD(SeaJS) 浏览器 同步的 只有加载完成,才能执行后面的操作。

- CommonJS(node.js) Node 同 SeaJS 同步的 也就是说,只有加载完成,才能执行后面的操作。

- ES6(js) 浏览器 ECMAScript2015 规定了新的模块加载方案 同 RequireJS 非同步加载模块,允许指定回调函数。

- 由于 Node.js 主要用于服务器编程,模块文件一般都已经存在于本地硬盘,所以加载起来比较快,不用考虑非同步加载的方式,所以 CommonJS 规范比较适用。

- 但是,如果是浏览器环境,要从服务器端加载模块,这时就必须采用非同步模式,因此浏览器端一般采用 AMD 规范。

- 首先为什么浏览器中不支持 CommonJS 语法呢?这是因为浏览器环境中并没有 module、 exports、 require 等环境变量。换句话说,webpack 打包后的文件之所以在浏览器中能运行,就是靠模拟了这些变量的行为。

- 完整的流程是 es6->es5(commonJS 规范)->浏览器可执行代码。

  1. es6->es5(commonJS 规范) babel

  2. es5(commonJS 规范)->浏览器可执行代码 webpack

[ES6 系列之模块加载方案](https://github.com/mqyqingfeng/Blog/issues/108)

[关于 webpack,babel,以及 es6 和 commonJS 之间的联系](https://blog.csdn.net/a250758092/article/details/78543440)

#### 6 图片上传到服务器的过程(FileReader.readAsDataURL()) 图片预览的做法 浏览器的兼容

```html
<input type="file" onchange="function(){}" />
<!-- 在高版本的浏览器中 通过onchange事件去调用FileReader.readAsDataURL 读取文件base64信息 放到img src中  实现图片预览 然后点击上传 上传file-->
<!-- https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsDataURL -->

<!-- 在低版本的浏览器中 onchange时 通过表单 把图片传给后端 后端处理 完毕 把图片信息给前端 前端放到img中 实现图片预览 点击上传 上传成功提醒 -->
```

[FileReader.readAsDataURL()](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsDataURL)

#### 7. token 存到 cookie 里,过期怎么处理?

- 为了兼容低版本浏览器 token 一般存在 cookie 里

- 过期了 直接跳转 登录页面 提醒重新登录

- 后端可以直接操作 cookie 帮忙重定向

#### 8. MongoDB 与 mysql 的优劣

- 数据灵活 Nosql 比如存一个人相关的 各种 信息 大数据

- 结构化数据 mysql 学校管理系统 数据结构稳定

#### 9. less(js) 、sass(ruby) 、 stylus 、css 命名空间 vue

- 网站风格 网站主题 的灵活改变 变量

#### 10. 工程化上的按需加载

- vue 配置即可

- react 需额外引入库 reloadable.js

#### 11. git 上的冲突

- conflict

- 产生冲突的原因是多人改变了同一段代码

- 解决办法是手动去修复

#### 12. 设计模式

前端常见的设计模式主要有以下几种:

1. 单例模式(这种设计模式的思想是确保一个类只有唯一实例,一般用于全局缓存,比如全局 window,唯一登录浮窗等.)

2. 工厂模式(工厂模式是创建对象的常用设计模式,为了不暴露创建对象的具体逻辑,将逻辑封装在一个函数中,这个函数就称为一个工厂.本质上是一个负责生产对象实例的工厂.工厂模式根据抽象程度的不同可以分为:简单工厂,工厂方法和抽象工厂.通常用于根据权限生成角色的场景)

3. 策略模式(把会变化的内容取出并封装起来,以便以后可以轻易地改动或扩充部分,而不影响不需要变化的其他部分;)

4. 代理模式(代理模式是为其他对象提供一种代理,也就是当其他对象直接访问该对象时,如果开销较大,就可以通过这个代理层控制对该对象的访问.常见的使用场景为懒加载,合并 http 请求和缓存.)

5. 观察者模式(也叫发布订阅模式,在这种模式中,一个订阅者订阅发布者,当一个特定的事件发生的时候,发布者会通知(调用)所有的订阅者.)

6. 模块模式(模块模式可以指定类想暴露的属性和方法,并且不会污染全局.)

7. 构造函数模式(构造函数和混合模式就是 js 中继承的两种实现方式,前者通过构造函数的形式定义类,通过 new 新增实例.而后者是将构造函数的引用属性和方法放到其原型上,子类是父类原型的一个实例.)

8. 混合模式

9. else 9.组合模式 10.继承模式 (9、10--》策略模式)

- 组合优于继承

- 本质:

  1. 初始,我们通过继承实现行为的重用,导致了代码的维护问题. -> 继承,

  2. 接着,我们将行为剥离成单独的类型并声明为不变内容的实例变量并通过 -> 组合

- 继承,可以实现静态代码的复用;组合,可以实现代码的弹性维护;使用组合代替继承,可以使代码更好地适应软件开发完后的需求变化.

- 策略模式的本质:少用继承,多用组合

- 另外总结如下:

1. 通过继承实现的代码复用容易引起牵一发而动全身的弊端.而且在父类中添加方法可以使不用拥有此方法的类也拥有此方法.

2. 通过组合实现的代码复用更具弹性,而且便于扩展.

3. 面向抽象编程可以提高程序的复用率.增加灵活性.

4. 策略模式的核心是,将问题的可变性和不可变性分开处理,将可变性单独抽取成接口,并且按照具体策略对其进行不同的实现,再通过类的组合达到代码复用,避免继承复用代码,每当需要添加新的方法是,就添加对应的接口和实现类,解决继承造成的代码复用问题.

[javascript 中常见的十五种设计模式](https://www.cnblogs.com/imwtr/p/9451129.html)

#### 13. webpack 插件的原理 loader 的作用

- Webpack 实质上是一个庞大的 Node.js 应用

- loader 的的作用是完成文件的某一步转换 翻译员

- 一个 Loader 的职责是单一的,只需要完成一种转换.

- 如果一个源文件需要经历多步转换才能正常使用,就通过多个 Loader 去转换. 在调用多个 Loader 去转换一个文件时,每个 Loader 会链式的顺序执行, 第一个 Loader 将会拿到需处理的原内容,上一个 Loader 处理后的结果会传给下一个接着处理,最后的 Loader 将处理后的最终结果返回给 Webpack.

- 所以,在你开发一个 Loader 时,请保持其职责的单一性,你只需关心输入和输出.

- 由于 Webpack 是运行在 Node.js 之上的,一个 Loader 其实就是一个 Node.js 模块,这个模块需要导出一个函数. 这个导出的函数的工作就是获得处理前的原内容,对原内容执行处理后,返回处理后的内容.

#### 14. typescript

#### 15. 跨域

```javascript
response.setHeader('Access-Control-Allow-Origin', '*')
```

- 简单的跨域请求 jsonp 即可,复杂的 cors,窗口之间 JS 跨域 postMessage,开发环境下接口跨域用 nginx 反向代理或 node 中间件比较方便

[前端常见跨域解决方案(全)](https://segmentfault.com/a/1190000011145364)

[CORS](https://developer.mozilla.org/zh-CN/docs/Glossary/CORS)

[HTTP 访问控制(CORS)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)

[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)

#### 16. http 与 hhtps

- http 运营商注入

#### 17. 浏览器渲染机制,渲染引擎及 js 引擎

- 回流 重绘

- 少回流 回流一定会触发重绘

#### 18. 浏览器的缓存机制

- 浏览器的缓存会造成用户不能及时加载最新的代码,这时可以使用 文件名后缀 hash 的办法来解决这个问题

- 现在都使用 webpack hash 来创建文件名 hash

- webpack 可以创建 3 种 hash

  hash & chunkhash & contenthash

- 一个例子(一般用 contenthash:文件内容发生变化才改变 hash)

```javascript
module.exports = {
  entry: {
    main: './src/index.js',
    slove: './src/slove.js',
  },

  output: {
    filename: '[name].[hash].js',
    path: path.resolve(__dirname, 'dist'),
  },
}
```

[令人困惑的 webpack 之 entry](https://segmentfault.com/a/1190000008288240)

[webpack 构建缓存机制-hash 介绍](https://www.jianshu.com/p/e609e7b55aa7)

#### 19. 在项目中遇到比较难的问题,如何解决?

(并不需要回答一个实际的问题,主要是解决的思路方法)

- 其实项目开发中应用层的问题,一般都有解决办法,有个说法,百度能解决 99%的问题,剩下的 1%交给 Google

- 而真正难的问题一般是业务逻辑上的问题,这就需要自己去思考,和同事领导沟通,然后解决

#### 20. 你公司项目的开发流程是什么?

- 一般业务来了的话,先做需求分析,分析哪些需求是要先做的,哪些是不够紧急的,分析用什么技术去做是最合适的

- 然后项目排期,

- 之后后端先行,制定接口格式和规范,

- 然后前端 mock 数据,结合 ui 开发

- 接口联调

- 线下线上测试

- 正式上线

- 遇到线上 bug 先回调版本,再线下解决 bug 再上线

- 当数据库解构发生了大的变化不可回调,只能抓紧修复当前版本的 bug

#### 21. 职业规划

<!-- - 自己的职业规划 (到大公司去)

  小公司 观察学习方法 瓶颈

  跳槽 好一点的公司 十几个前端的

  二线互联网公司 可以混资历 练技术

  bat

- 回答 hr (学习,稳定)

  学习 更优秀 跟随公司的脚步 带领技术团队 -->

#### 22. 优雅编程的思考

多看优秀的代码和开源项目,学习优秀的人是如何写出优秀的代码

#### 23. 代码注释问题

- 一般给业务逻辑添加注释

- 而代码的话,写的够好,够规范,是不需要注释的

#### 24. 扩展性 复用性 冲突

- 扩展性优先

- 封装一个组件留一个 slot

#### 25. 一门技术深入学习的思路

- 文档 demo 文档 源码 社区

#### 26. 遇到不合理的事情怎么办?你在公司经常发邮件吗?为什么呢?

- 不合理的问题 说 no 工作就是为了钱

- 发邮件 保留证据 周报 甩锅 周知

#### 27.Node 自动重启工具 nodemon

- PM2 守护 node 进程不被停止,发布到线上时使用。

- nodemon 修改代码自动重启,开发时使用很方便。

- nrm npm 下载源管理

- nvm node 版本管理

[Node 自动重启工具 nodemon](https://github.liwenfeng.net/2018/03/18/nodemon.html)

#### 28.服务器端渲染和客户端渲染

[服务器端渲染和客户端渲染](https://github.liwenfeng.net/2018/04/11/ServerSideRenderingAndClientSideSendering.html)

#### 29.检测是否支持 audio 自动播放

```javascript
function testAutoPlay() {
  // 返回一个promise以告诉调用者检测结果
  return new Promise((resolve) => {
    const audio = document.createElement('audio')
    // require一个本地文件,会变成base64格式
    // audio.src = require('/src/alert.mp3')
    audio.src =
      'https://m8.music.126.net/20200530122212/be3d9b8f95a783b00e5eeae01edc7af8/ymusic/2c18/e557/08f0/1d5482df6396762a27043e6a973b3079.mp3'
    document.body.appendChild(audio)
    const onLoad = (isSupport) => {
      audio.remove()
      resolve(isSupport)
    }
    // play返回的是一个promise
    audio
      .play()
      .then(() => {
        // 支持自动播放
        onLoad(true)
      })
      .catch((err) => {
        console.log(err)
        // 不支持自动播放
        onLoad(false)
      })
  })
}
testAutoPlay().then((isSupport) => console.log(isSupport))
```

[让 Chrome 浏览器支持音频自动播放](https://github.liwenfeng.net/2018/06/13/chrome-flags-autoplay-policy.html)

#### 30.一些其他问题

[fe](https://github.liwenfeng.net/2018/09/01/fe-question.html)

#### 31.JWT

JSON Web 令牌是一种开放的行业标准 RFC 7519 方法,用于在双方之间安全地表示声明。

[JWT](https://github.liwenfeng.net/2019/09/24/JWT.html)

#### 32.Restful API

[Restful API](https://github.liwenfeng.net/2019/09/24/RestfulAPI.html)

[http 方法有哪些?get、post、put、delete,为什么一般只用过 get 和 post?什么时候用 put、delete,为什么没用过](https://blog.csdn.net/f45056231p/article/details/84974066)

[HTTP 中的 PUT 和 DELETE 到底有什么用处?](https://www.v2ex.com/t/373770)

#### 33.graphql

[graphql](https://graphql.cn/)

#### 34.最简实现 Promise,支持异步链式调用(20 行)

[最简实现 Promise,支持异步链式调用(20 行)](https://juejin.im/post/5e6f4579f265da576429a907)

[剖析 Promise 内部结构,一步一步实现一个完整的、能通过所有 Test case 的 Promise 类](https://github.com/xieranmaya/blog/issues/3)

#### 35.手写 new (如何模拟实现一个 new 的效果?)

**new**被调用后做了三件事情:

1. 让实例可以访问到私有属性

2. 让实例可以访问构造函数原型(constructor.prototype)所在原型链上的属性

3. 如果构造函数返回的结果不是引用数据类型

```js
function newFactory(ctor, ...args) {
  if (typeof ctor !== 'function') {
    throw 'newOperator function the first param must be a function'
  }

  let obj = new Object()
  obj.__proto__ = Object.create(ctor.prototype)
  let res = ctor.apply(obj, ...args)

  let isObject = typeof res === 'object' && typeof res !== null
  let isFunction = typeof res === 'function'
  return isObject || isFunction ? res : obj
}
```

[如何模拟实现一个 new 的效果?](http://47.98.159.95/my_blog/js-api/001.html)

[JavaScript 深入之 new 的模拟实现](https://github.com/mqyqingfeng/Blog/issues/13)

[new 运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)

[Object.create()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

[typeof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof)

[Arguments 对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments)

[...剩余参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters)

[默认参数值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters)

[解构赋值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)

[throw](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/throw)

[Object.prototype.\_\_proto\_\_](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)

[js 中\_\_proto\_\_和 prototype 的区别和关系？](https://www.zhihu.com/question/34183746)

#### 36.手写 bind (如何模拟实现一个 bind 的效果?)

> bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )

- 实现**bind**之前，我们首先要知道它做了哪些事情。

1. 对于普通函数，绑定 this 指向

2. 对于构造函数，要保证原函数的原型对象上的属性不能丢失

```js
Function.prototype.mybind = function (context, ...args) {
  // 异常处理
  if (typeof this !== 'function') {
    throw new Error(
      'Function.prototype.bind - what is trying to be bound is not callable'
    )
  }
  // 保存 this 的值,它代表调用 bind 的函数
  var self = this
  var fNOP = function () {}

  var fbound = function () {
    self.apply(
      this instanceof self ? this : context,
      args.concat(Array, prototype.slice.call(arguments))
    )
  }

  fNOP.portotype = this.prototype
  fbound.prototype = new fNOP()

  return fbound
}
```

- 也可以这么用 Object.create 来处理原型:

```js
Function.prototype.bind = function (context, ...args) {
  if (typeof this !== 'function') {
    throw new Error(
      'Function.prototype.bind - what is trying to be bound is not callable'
    )
  }

  var self = this

  var fbound = function () {
    self.apply(
      this instanceof self ? this : context,
      args.concat(Array.prototype.slice.call(arguments))
    )
  }

  fbound = Object.create(this.prototype)

  return fbound
}
```

[JavaScript 深入之 bind 的模拟实现](https://github.com/mqyqingfeng/Blog/issues/12)

[Function.prototype.bind()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)

#### 37.手写 call/apply (如何实现一个 call/apply 函数?)

> call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。

```js
Function.prototype.mycall = function (context) {
  var context = context || window
  context.fn = this

  var args = []
  for (var i = 1, len = arguments.length; i < len; i++) {
    args.push('arguments[' + i + ']')
  }

  var result = eval('context.fn(' + args + ')')

  delete context.fn
  return result
}
```

- ES6 解构

```js
Function.prototype.mycall = function (context, ...args) {
  var context = context || window
  context.fn = this

  var result = eval('context.fn(...args)')

  delete context.fn
  return result
}
```

- 类似的，有 apply 的对应实现:

```js
Function.prototype.apply = function (context, args) {
  let context = context || window
  context.fn = this
  let result = eval('context.fn(...args)')

  delete context.fn
  return result
}
```

[JavaScript 深入之 call 和 apply 的模拟实现](https://github.com/mqyqingfeng/Blog/issues/11)

[Function.prototype.call()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)

[Function.prototype.apply()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)

#### 38.git clone 太慢怎么解决?

只需要将

https://github.com/

改为

https://github.com.cnpmjs.org/

就可以实现一键式加速。

亲测访问以及 git clone 有效

#### 39.手写 ajax

```js
// 简单版
var xhr = new XMLHttpRequest(),
  method = 'GET',
  url = 'https://developer.mozilla.org/'

xhr.open(method, url, true)
xhr.onreadystatechange = function () {
  if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
    console.log(xhr.responseText)
  }
}
xhr.send()
```

```js
// 封装版
// 获取异步请求对象
function getXhr() {
  var xhr = null
  if (window.XMLHttpRequest) {
    xhr = new XMLHttpRequest()
  } else {
    // <ie8
    xhr = new ActiveXObject('Microsoft.XMLHttp')
  }
  return xhr
}
// 封装 ajax 函数
// url:"url路径"  type:请求方式  data:请求参数类型  dataType：返回的字符串类型
function ajax({ url, type, data, dataType }) {
  return new Promise(function (resolve, reject) {
    // 创建异步请求对象
    var xhr = getXhr()
    // var xhr = window.XMLHttpRequest ? new XMLHttprequest() : new ActiveXObject('Microsoft.XMLHttp');

    // get
    if (type.toLowerCase() === 'get' && data !== undefined) {
      url += '?' + data
    }
    // open true表示异步
    xhr.open(type, url, true)
    // post
    if (type.toLowerCase() === 'post') {
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
    }
    // post send
    if (type.toLowerCase() === 'post' && data !== undefined) {
      xhr.send(data)
    } else {
      xhr.send(null)
    }

    // 绑定监听事件
    xhr.onreadystatechange = function () {
      // 4 200 ok
      if (xhr.readyState === 4 && xhr.status === 200) {
        // json
        if (dataType !== undefined && dataType.toLowerCase() === 'json') {
          var res = JSON.parse(xhr.responseText)
        } else {
          var res = xhr.responseText
        }
        resolve(res)
      }
    }
  })
}
```

[XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)

[POST 提交数据之---Content-Type 的理解](https://www.cnblogs.com/tugenhua0707/p/8975121.html)

[Content-Type](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type)

[POST](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST)

[幂等](https://developer.mozilla.org/zh-CN/docs/Glossary/%E5%B9%82%E7%AD%89)

#### 40.js 中\_\_proto\_\_和 prototype 的区别和关系？

- 首先，要明确几个点：

1. 在 JS 里，万物皆对象。方法(Function)是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。即：对象具有属性\_\_proto\_\_，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。

2. 方法(Function)方法这个特殊的对象，除了和其他对象一样有上述\_\_proto\_\_属性之外，还有自己特有的属性——原型属性(prototype)，这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法(我们把这个对象叫做原型对象)。原型对象也有一个属性，叫做 constructor，这个属性包含了一个指针，指回原构造函数。

- 总结：

1. 对象有属性\_\_proto\_\_,指向该对象的构造函数的原型对象。

2. 方法除了有属性\_\_proto\_\_,还有属性 prototype，prototype 指向该方法的原型对象。

[js 中\_\_proto\_\_和 prototype 的区别和关系？](https://www.zhihu.com/question/34183746/answer/58155878)

### nuxt

[nuxt](https://zh.nuxtjs.org/guide)

### element-ui

[element-ui](https://element.eleme.cn/#/zh-CN/component/container)

### 其他

[阿里前端攻城狮们写了一份前端面试题答案,请查收(一)](https://github.com/mqyqingfeng/frontend-interview-question-and-answer/issues/30)

[冴羽的博客 js](https://github.com/mqyqingfeng/Blog)

[我的博客](https://github.liwenfeng.net/)

[fe](https://github.liwenfeng.net/2018/09/01/fe-question.html)

[fend](https://github.liwenfeng.net/2018/09/02/fend.html)

[Ramda 函数库参考教程 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2017/03/ramda.html)

[Lodash](https://www.lodashjs.com/docs/latest#_pullallbyarray-values-iteratee_identity)

[Ramda](https://ramda.cn/docs/#composeWith)

[Content Security Policy 入门教程 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2016/09/csp.html)

[Pointfree 编程风格指南 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2017/03/pointfree.html)

[函数式编程入门教程 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)

[Javascript 面向对象编程(一)：封装 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html)

[MVC，MVP 和 MVVM 的图示 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)

[谈谈 MVC 模式 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2007/11/mvc.html)

[ljianshu/Blog: 关注基础知识，打造优质前端博客，公众号[前端工匠]的作者](https://github.com/ljianshu/Blog)

[2020 最新前端中高级面试题](https://www.cnblogs.com/liuhao-web/p/11589848.html)

[2020 前端面试(一面面试题)](https://zhuanlan.zhihu.com/p/84212558?from_voters_page=true)

[2020 年前端面试集锦(HTML CSS 原生 JS )](https://www.jianshu.com/p/9de496b5c529)

[2020 前端面试：第一波面试题总结](https://www.cnblogs.com/ZXH-null/p/12294427.html)

[2020 前端面试集锦](https://zhuanlan.zhihu.com/p/115248669)

[【精心整理】2020 年大前端面试题库 - 备战明年金三银四](https://www.jianshu.com/p/83e74528892c)

[2020 年，web 前端还好找工作吗？](https://www.zhihu.com/question/398846478/answer/1266515153)

```html
<!-- javascript 采用词法作用域(lexical scoping),也就是静态作用域. -->

<!--  javascript 的可执行代码(executable code)的类型 其实很简单,就三种,全局代码、函数代码、eval代码.  -->

<!-- 执行上下文(execution context) -->

<!-- 执行上下文栈(Execution context stack,ECS) -->

<!--
对于每个执行上下文,都有三个重要属性:
变量对象(Variable object,VO)
作用域链(Scope chain)
this
-->

<!-- 在函数上下文中,我们用活动对象(activation object, AO)来表示变量对象. -->
```

```js
Element.prototype instanceof Node // true
```
